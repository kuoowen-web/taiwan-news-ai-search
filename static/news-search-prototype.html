<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Âè∞ÁÅ£Êñ∞ËÅû AI ÊêúÂ∞ãÂºïÊìé</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background: #f5f5f5;
            color: #1a1a1a;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }

        /* Header */
        header {
            background: white;
            border-bottom: 1px solid #e5e5e5;
            padding: 16px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 700;
            color: #2563eb;
        }

        .my-searches {
            color: #666;
            text-decoration: none;
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .my-searches:hover {
            background: #f5f5f5;
            color: #1a1a1a;
        }

        .btn-new-thread {
            background: white;
            border: 1px solid #e5e5e5;
            color: #666;
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-new-thread:hover {
            border-color: #2563eb;
            color: #2563eb;
        }

        /* Mode Toggle Buttons */
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            background: white;
            padding: 4px;
            border-radius: 8px;
            border: 1px solid #e5e5e5;
        }

        .mode-button {
            padding: 6px 14px;
            font-size: 13px;
            font-weight: 500;
            color: #666;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .mode-button:hover {
            background: #f5f5f5;
            color: #1a1a1a;
        }

        .mode-button.active {
            background: #2563eb;
            color: white;
        }

        .mode-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a90e2;
            color: white;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
            margin-left: 4px;
            position: relative;
        }

        .mode-info-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .mode-info-icon:hover::before {
            content: '';
            position: absolute;
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #333;
            z-index: 1000;
        }

        /* Research Mode Selector */
        .research-mode-selector {
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .research-mode-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .research-mode-options {
            display: flex;
            gap: 8px;
        }

        .research-mode-option {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .research-mode-option:hover {
            border-color: #2563eb;
            background: #f0f7ff;
        }

        .research-mode-option.active {
            border-color: #2563eb;
            background: #eff6ff;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .research-mode-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .research-mode-content {
            flex: 1;
            text-align: left;
        }

        .research-mode-name {
            font-size: 13px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 2px;
        }

        .research-mode-desc {
            font-size: 11px;
            color: #6b7280;
            line-height: 1.3;
        }

        .research-mode-option.active .research-mode-name {
            color: #2563eb;
        }

        .research-mode-option.active .research-mode-desc {
            color: #1d4ed8;
        }

        /* KG Toggle */
        .kg-toggle-container {
            margin-top: 12px;
            padding: 10px 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .kg-toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            user-select: none;
        }

        .kg-toggle-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .kg-toggle-text {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #374151;
            flex-wrap: wrap;
        }

        .kg-toggle-icon {
            font-size: 16px;
        }

        .kg-toggle-hint {
            font-size: 11px;
            color: #6b7280;
            font-style: italic;
        }

        .kg-toggle-label:hover .kg-toggle-text {
            color: #2563eb;
        }


        /* Main Content */
        main {
            min-height: calc(100vh - 200px);
            padding: 48px 0;
        }

        /* Initial State */
        .initial-state {
            max-width: 800px;
            margin: 120px auto 0;
            text-align: center;
        }

        .initial-state h1 {
            font-size: 32px;
            margin-bottom: 16px;
            color: #1a1a1a;
        }

        .initial-state p {
            font-size: 16px;
            color: #666;
            margin-bottom: 48px;
        }

        /* Search Input */
        .search-container {
            max-width: 800px;
            margin: 0 auto 32px;
        }

        .search-box {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 16px;
            transition: all 0.3s;
        }

        .search-box:focus-within {
            box-shadow: 0 4px 16px rgba(37,99,235,0.15);
        }

        .search-input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 16px;
            resize: none;
            min-height: 80px;
            font-family: inherit;
        }

        .search-input::placeholder {
            color: #999;
        }

        .search-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 12px;
        }

        .btn-search {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-search:hover {
            background: #1d4ed8;
        }

        .btn-search:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Memory Notification */
        .memory-notification {
            background: linear-gradient(135deg, #e8f4f8 0%, #d4e9f2 100%);
            border-left: 4px solid #2563eb;
            padding: 16px 20px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.1);
            transition: opacity 0.3s ease;
        }

        .memory-icon {
            font-size: 24px;
        }

        .memory-text {
            color: #1a1a1a;
            font-weight: 500;
            font-size: 15px;
            flex: 1;
        }

        /* Knowledge Graph Display (Phase KG) */
        .kg-display-container {
            background: white;
            border-radius: 12px;
            padding: 0;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 2px solid #e0e7ff;
        }

        .kg-display-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
            border-radius: 12px 12px 0 0;
        }

        .kg-display-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 600;
            color: #1e293b;
        }

        .kg-display-icon {
            font-size: 20px;
        }

        .kg-display-metadata {
            font-size: 12px;
            font-weight: 400;
            color: #64748b;
            margin-left: 8px;
        }

        .kg-toggle-button {
            background: transparent;
            border: 1px solid #cbd5e1;
            color: #64748b;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .kg-toggle-button:hover {
            background: #f1f5f9;
            color: #475569;
            border-color: #94a3b8;
        }

        .kg-display-content {
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
        }

        .kg-display-content.collapsed {
            display: none;
        }

        .kg-display-empty {
            padding: 40px 20px;
            text-align: center;
            color: #64748b;
            font-size: 14px;
        }

        .kg-section {
            margin-bottom: 20px;
        }

        .kg-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #475569;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .kg-item {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: #f8fafc;
            border-left: 3px solid #cbd5e1;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
        }

        .kg-item-name {
            font-weight: 600;
            color: #1e293b;
        }

        .kg-item-type {
            display: inline-block;
            padding: 2px 8px;
            background: #e0e7ff;
            color: #4338ca;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 8px;
        }

        .kg-item-confidence {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 4px;
        }

        .kg-item-confidence.high {
            background: #d1fae5;
            color: #065f46;
        }

        .kg-item-confidence.medium {
            background: #fef3c7;
            color: #92400e;
        }

        .kg-item-confidence.low {
            background: #e5e7eb;
            color: #6b7280;
        }

        .kg-item-desc {
            color: #64748b;
            margin-top: 4px;
        }

        .kg-relationship-arrow {
            color: #2563eb;
            margin: 0 6px;
        }

        /* Chat UI for Free Conversation Mode */
        .chat-container {
            display: none;
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .chat-container.active {
            display: block;
        }

        .chat-messages {
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 16px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .chat-message {
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.assistant {
            align-items: flex-start;
        }

        .chat-message-header {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .chat-message-bubble {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.6;
        }

        .chat-message.user .chat-message-bubble {
            background: #2563eb;
            color: white;
        }

        .chat-message.assistant .chat-message-bubble {
            background: white;
            color: #1a1a1a;
            border: 1px solid #e5e5e5;
        }

        .chat-reference-info {
            font-size: 11px;
            color: #999;
            margin-top: 8px;
            padding: 8px 12px;
            background: #f0f9ff;
            border-radius: 6px;
            border-left: 3px solid #2563eb;
        }

        /* Multi-dimensional Parallel Clarification Styles */
        .chat-message.clarification .chat-message-bubble {
            max-width: 90%;
            background: transparent;
            border: none;
            padding: 0;
        }

        .clarification-card {
            background: #fffbeb;
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 20px;
            margin: 0;
        }

        .clarification-header {
            font-size: 16px;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .question-block {
            margin-bottom: 20px;
        }

        .question-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-weight: 500;
            color: #1a1a1a;
        }

        .question-icon {
            font-size: 20px;
            line-height: 1;
        }

        .question-text {
            font-size: 15px;
        }

        .required {
            color: #dc2626;
            margin-left: 4px;
            font-weight: 600;
        }

        .options-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .option-chip {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 20px;
            background: white;
            color: #374151;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            outline: none;
        }

        .option-chip:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            transform: translateY(-1px);
        }

        .option-chip.selected {
            border-color: #2563eb;
            background: #2563eb;
            color: white;
        }

        .submit-clarification {
            width: 100%;
            padding: 12px 24px;
            margin-top: 16px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            outline: none;
        }

        .submit-clarification:hover:not(:disabled) {
            background: #1d4ed8;
            transform: translateY(-1px);
        }

        .submit-clarification:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .chat-input-container {
            margin-top: 16px;
            border-top: 1px solid #e5e5e5;
            padding-top: 16px;
        }

        .chat-loading {
            display: none;
            text-align: center;
            padding: 16px;
            color: #666;
        }

        .chat-loading.active {
            display: block;
        }

        .chat-loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #e5e5e5;
            border-top-color: #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 8px;
        }

        /* Conversation History */
        .conversation-history {
            background: white;
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .conversation-history-header {
            font-size: 14px;
            font-weight: 700;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .conversation-history-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .conversation-history-item {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background: #f9fafb;
            border-radius: 6px;
            font-size: 14px;
            line-height: 1.5;
            cursor: pointer;
            transition: all 0.2s;
        }

        .conversation-history-item:hover {
            background: #e8f4f8;
            border-left: 3px solid #2563eb;
            padding-left: 9px;
        }

        .conversation-number {
            color: #2563eb;
            font-weight: 600;
            min-width: 24px;
        }

        .conversation-text {
            color: #333;
            flex: 1;
        }

        /* Loading State */
        .loading-state {
            text-align: center;
            padding: 48px 0;
            display: none;
        }

        .loading-state.active {
            display: block;
        }

        .loading-text {
            font-size: 18px;
            color: #666;
            margin-top: 16px;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #e5e5e5;
            border-top-color: #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Results Section */
        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
        }

        /* AI Summary */
        .ai-summary {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 32px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .ai-summary-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #2563eb;
        }

        .summary-section {
            margin-bottom: 20px;
        }

        .summary-section:last-of-type {
            margin-bottom: 0;
        }

        .summary-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #1a1a1a;
        }

        .summary-content {
            color: #333;
            line-height: 1.7;
        }

        .timeline-item {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .timeline-item:last-child {
            margin-bottom: 0;
        }

        .entity-item {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .related-link {
            color: #2563eb;
            text-decoration: none;
            display: inline-block;
            margin-right: 16px;
            margin-bottom: 8px;
        }

        .related-link:hover {
            text-decoration: underline;
        }

        .summary-footer {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .source-info {
            font-size: 14px;
            color: #666;
        }

        .feedback-buttons {
            display: flex;
            gap: 16px;
        }

        .btn-feedback {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .btn-feedback:hover {
            background: #f5f5f5;
        }

        /* View Tabs */
        .view-tabs {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            border-bottom: 2px solid #e5e5e5;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            position: relative;
            transition: all 0.2s;
        }

        .tab.active {
            color: #2563eb;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: #2563eb;
        }

        /* Summary Toggle */
        .summary-toggle {
            display: none;
            margin-bottom: 24px;
        }

        .summary-toggle.active {
            display: block;
        }

        .btn-toggle-summary {
            background: white;
            border: 1px solid #e5e5e5;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-toggle-summary:hover {
            border-color: #2563eb;
            color: #2563eb;
        }

        /* Summary Loading */
        .summary-loading {
            display: none;
            text-align: center;
            padding: 24px;
            background: white;
            border-radius: 12px;
            margin-bottom: 16px;
            color: #666;
        }

        .summary-loading.active {
            display: block;
        }

        /* News Cards */
        .news-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .news-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.2s;
        }

        .news-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .news-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 12px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .news-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
        }

        .relevance {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stars {
            color: #fbbf24;
        }

        .news-excerpt {
            color: #333;
            line-height: 1.7;
            margin-bottom: 16px;
            display: none;
        }

        .news-excerpt.visible {
            display: block;
        }

        .btn-read-more {
            color: #2563eb;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .btn-read-more:hover {
            text-decoration: underline;
        }

        /* Timeline View */
        .timeline-view {
            display: none;
        }

        .timeline-view.active {
            display: block;
        }

        .timeline-date {
            position: relative;
            padding-left: 40px;
            margin-bottom: 32px;
        }

        .timeline-date::before {
            content: '';
            position: absolute;
            left: 12px;
            top: 12px;
            bottom: -32px;
            width: 2px;
            background: rgba(37,99,235,0.2);
        }

        .timeline-date:last-child::before {
            display: none;
        }

        .timeline-dot {
            position: absolute;
            left: 4px;
            top: 8px;
            width: 12px;
            height: 12px;
            background: #2563eb;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 0 2px #2563eb;
        }

        .date-label {
            font-size: 16px;
            font-weight: 700;
            color: #2563eb;
            margin-bottom: 16px;
        }

        /* Bottom Actions */
        .bottom-actions {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 48px;
            padding: 24px 0;
        }

        .btn-action {
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-share {
            background: #2563eb;
            border: none;
            color: white;
        }

        .btn-share:hover {
            background: #1d4ed8;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
        }

        .modal.modal-large {
            max-width: 700px;
        }

        /* Saved Sessions List */
        .saved-sessions-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 24px;
        }

        .saved-session-item {
            padding: 16px;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .saved-session-item:hover {
            border-color: #2563eb;
            background: #f9fafb;
        }

        .delete-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: #f3f4f6;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
            min-width: 24px;
            text-align: center;
        }

        .delete-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }

        .delete-btn.confirming {
            background: #ef4444;
            color: white;
            border-color: #dc2626;
            padding: 4px 12px;
            font-size: 12px;
        }

        .delete-btn.confirming:hover {
            background: #dc2626;
        }

        .saved-session-title {
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 8px;
        }

        .saved-session-meta {
            font-size: 13px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .saved-session-queries {
            font-size: 12px;
            color: #999;
        }

        .empty-sessions {
            text-align: center;
            padding: 48px 24px;
            color: #666;
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 24px;
            text-align: center;
        }

        .modal-content {
            margin-bottom: 24px;
        }

        .modal-description {
            color: #666;
            margin-bottom: 16px;
        }

        .copy-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .btn-copy {
            padding: 12px 16px;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            background: white;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .btn-copy:hover {
            border-color: #2563eb;
            background: #eff6ff;
        }

        .modal-tip {
            background: #eff6ff;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            color: #666;
            margin-top: 16px;
        }

        .modal-actions {
            display: flex;
            justify-content: center;
        }

        .btn-close-modal {
            padding: 10px 32px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-close-modal:hover {
            background: #f5f5f5;
        }

        /* Styling for source links in generated answers */
        .source-link {
            color: #3b82f6;
            /* Blue color for links */
            text-decoration: none;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .source-link:hover {
            color: #2563eb;
            /* Darker blue on hover */
            background-color: #dbeafe;
            /* Light blue background on hover */
            text-decoration: underline;
        }

        /* Ensure summary content has proper spacing for line breaks */
        .summary-content {
            line-height: 1.8;
            /* Better readability */
        }

        /* Deep Research Progress Display */
        .reasoning-progress-container {
            background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .progress-header {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 15px;
            color: #334155;
        }

        .progress-stages {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background: white;
            border-radius: 8px;
            opacity: 0.4;
            transition: opacity 0.3s, transform 0.3s;
            min-width: 100px;
        }

        .stage.active {
            opacity: 1;
            animation: pulse 1.5s infinite;
            transform: scale(1.05);
        }

        .stage.complete {
            opacity: 1;
        }

        .stage .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .stage .label {
            font-size: 12px;
            font-weight: 500;
            color: #64748b;
        }

        .stage .status {
            font-size: 11px;
            margin-top: 5px;
            color: #059669;
        }

        .progress-details {
            text-align: center;
            font-size: 13px;
            color: #475569;
            font-style: italic;
            min-height: 20px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1.05); }
            50% { transform: scale(1.1); }
        }

        /* Citation Links */
        .citation-link {
            color: #2563eb;
            text-decoration: none;
            font-weight: 600;
            padding: 0 2px;
            transition: all 0.2s;
            border-bottom: 1px solid transparent;
        }

        .citation-link:hover {
            color: #1d4ed8;
            border-bottom-color: #1d4ed8;
            background: #eff6ff;
        }
        /* Knowledge Graph D3 Visualization (Phase KG Enhanced) */
        .kg-graph-container {
            width: 100%;
            height: 400px;
            background: #fafbfc;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .kg-graph-container svg {
            width: 100%;
            height: 100%;
        }

        .kg-view-toggle {
            display: flex;
            gap: 4px;
            background: #f1f5f9;
            padding: 4px;
            border-radius: 8px;
        }

        .kg-view-btn {
            background: transparent;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            color: #64748b;
            transition: all 0.2s;
        }

        .kg-view-btn.active {
            background: white;
            color: #1e293b;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .kg-view-btn:hover:not(.active) {
            color: #475569;
        }

        .kg-node {
            cursor: pointer;
        }

        .kg-node circle {
            stroke: white;
            stroke-width: 2px;
            transition: all 0.2s;
        }

        .kg-node:hover circle {
            stroke-width: 3px;
            filter: brightness(1.1);
        }

        .kg-node text {
            font-size: 11px;
            fill: #1e293b;
            pointer-events: none;
            text-anchor: middle;
        }

        .kg-link {
            stroke-opacity: 0.6;
            fill: none;
        }

        .kg-link-label {
            font-size: 10px;
            fill: #64748b;
            pointer-events: none;
        }

        .kg-tooltip {
            position: absolute;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 13px;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .kg-tooltip.visible {
            opacity: 1;
        }

        .kg-tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #1e293b;
        }

        .kg-tooltip-type {
            display: inline-block;
            padding: 2px 6px;
            background: #e0e7ff;
            color: #4338ca;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 6px;
        }

        .kg-tooltip-desc {
            color: #64748b;
            line-height: 1.5;
        }

        .kg-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px 0;
            border-top: 1px solid #e5e7eb;
            margin-top: 12px;
        }

        .kg-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #64748b;
        }

        .kg-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
    <!-- D3.js for Knowledge Graph Visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    üîç Âè∞ÁÅ£Êñ∞ËÅûÊêúÂ∞ã
                </div>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button class="btn-new-thread" id="btnNewThread">
                        <span>üîÑ</span>
                        <span>ÂÑ≤Â≠ò‰∏¶ÈñãÂïüÊñ∞Â∞çË©±</span>
                    </button>
                    <button class="my-searches" id="btnMySearches" style="border: none; background: none;">ÊàëÁöÑÊêúÂ∞ã</button>
                </div>
            </div>
        </div>
    </header>

    <main>
        <div class="container">
            <!-- Initial State -->
            <div class="initial-state" id="initialState">
                <h1>Áî®Ëá™ÁÑ∂Ë™ûË®ÄÊêúÂ∞ãÊúÄÊñ∞Êñ∞ËÅû</h1>
                <p>Èö®ÊôÇÊéåÊè°‰∫ãÂØ¶ÁöÑÂÖ®Ë≤åÔºåËÆì AI ÊõøÊÇ®Êï¥ÁêÜÂ§öÂÆ∂Â™íÈ´îÁöÑËßÄÈªû</p>
            </div>

            <!-- Search Container -->
            <div class="search-container" id="searchContainer">
                <div class="search-box">
                    <textarea
                        class="search-input"
                        id="searchInput"
                        placeholder="ÂïèÊàë‰ªª‰ΩïÊñ∞ËÅûÁõ∏ÈóúÂïèÈ°åÔºå‰æãÂ¶ÇÔºöÊúÄËøëÂè∞ÁÅ£Ë≥áÂÆâÊîøÁ≠ñÊúâ‰ªÄÈ∫ºÈÄ≤Â±ïÔºü"
                    ></textarea>
                    <div class="search-actions">
                        <div class="mode-toggle" id="modeToggle">
                            <button class="mode-button active" data-mode="search">Êñ∞ËÅûÊêúÂ∞ã</button>
                            <button class="mode-button" data-mode="deep_research">Deep Research</button>
                            <button class="mode-button" data-mode="chat">Ëá™Áî±Â∞çË©±</button>
                            <span class="mode-info-icon" data-tooltip="Deep Research: Ê∑±Â∫¶ÂàÜÊûêÔºå‰ΩøÁî® Actor-Critic Â§öËº™Êé®ÁêÜÔºõËá™Áî±Â∞çË©±ÔºöÂü∫ÊñºÁï∂ÂâçÂ∞çË©±ÂÖßÂÆπÂõûÁ≠îÔºå‰∏çËß∏ÁôºÊêúÂ∞ã">?</span>
                        </div>

                        <!-- Research Mode Selector (visible only when Deep Research is selected) -->
                        <div class="research-mode-selector" id="researchModeSelector" style="display: none;">
                            <label class="research-mode-label">üîß Á†îÁ©∂Ê®°Âºè</label>
                            <div class="research-mode-options">
                                <button class="research-mode-option active" data-research-mode="discovery">
                                    <span class="research-mode-icon">üîç</span>
                                    <div class="research-mode-content">
                                        <div class="research-mode-name">Âª£Ê≥õÊé¢Á¥¢</div>
                                        <div class="research-mode-desc">ÂåÖÂê´Á§æÁæ§/Ë´ñÂ£á (Tier 1-5)</div>
                                    </div>
                                </button>
                                <button class="research-mode-option" data-research-mode="strict">
                                    <span class="research-mode-icon">‚úì</span>
                                    <div class="research-mode-content">
                                        <div class="research-mode-name">Âö¥Ë¨πÊü•Ê†∏</div>
                                        <div class="research-mode-desc">ÂÉÖÂÆòÊñπ/Ê¨äÂ®Å (Tier 1-2)</div>
                                    </div>
                                </button>
                                <button class="research-mode-option" data-research-mode="monitor">
                                    <span class="research-mode-icon">üìä</span>
                                    <div class="research-mode-content">
                                        <div class="research-mode-name">ÊÉÖÂ†±Áõ£Ê∏¨</div>
                                        <div class="research-mode-desc">ÊØîÂ∞çÂÆòÊñπËàáÊ∞ëÈñìËêΩÂ∑Æ</div>
                                    </div>
                                </button>
                            </div>
                        </div>

                        <!-- KG Toggle (visible only when Deep Research is selected) -->
                        <div class="kg-toggle-container" id="kgToggleContainer" style="display: none;">
                            <label class="kg-toggle-label">
                                <input type="checkbox" id="kgToggle" class="kg-toggle-checkbox">
                                <span class="kg-toggle-text">
                                    <span class="kg-toggle-icon">üìä</span>
                                    ÂïüÁî®Áü•Ë≠òÂúñË≠ú (Knowledge Graph)
                                    <span class="kg-toggle-hint">Êé®Ë´ñÊôÇÈñìÁ¥ÑÂ¢ûÂä† 2-3 Áßí</span>
                                </span>
                            </label>
                        </div>

                        <button class="btn-search" id="btnSearch">ÊêúÂ∞ã</button>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div class="loading-state" id="loadingState">
                <div class="loading-spinner"></div>
                <div class="loading-text">ü§ñ Ê≠£Âú®ÂàÜÊûêÊÇ®ÁöÑÂïèÈ°å...</div>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="resultsSection">
                <!-- Knowledge Graph Display (Phase KG Enhanced) -->
                <div class="kg-display-container" id="kgDisplayContainer" style="display: none;">
                    <div class="kg-display-header">
                        <div class="kg-display-title">
                            <span class="kg-display-icon">üìä</span>
                            <span>Áü•Ë≠òÂúñË≠ú</span>
                            <span class="kg-display-metadata" id="kgMetadata"></span>
                        </div>
                        <div style="display: flex; gap: 12px; align-items: center;">
                            <!-- View Toggle -->
                            <div class="kg-view-toggle" id="kgViewToggle">
                                <button class="kg-view-btn active" data-view="graph">ÂúñÂΩ¢</button>
                                <button class="kg-view-btn" data-view="list">ÂàóË°®</button>
                            </div>
                            <button class="kg-toggle-button" id="kgToggleButton">
                                <span id="kgToggleIcon">‚ñº</span> Êî∂Ëµ∑
                            </button>
                        </div>
                    </div>
                    <!-- Graph View -->
                    <div class="kg-graph-container" id="kgGraphView">
                        <div class="kg-tooltip" id="kgTooltip"></div>
                    </div>
                    <!-- List View -->
                    <div class="kg-display-content" id="kgDisplayContent" style="display: none;">
                        <!-- KG list content will be populated here -->
                    </div>
                    <!-- Legend -->
                    <div class="kg-legend" id="kgLegend" style="padding: 12px 20px;"></div>
                    <div class="kg-display-empty" id="kgDisplayEmpty" style="display: none;">
                        ‚ÑπÔ∏è Ê≠§Êü•Ë©¢‰∏çÈÅ©ÂêàÁîüÊàêÁü•Ë≠òÂúñË≠úÔºà‰æãÂ¶ÇÔºöÁ¥îÁ≤πÁöÑÊÑèË¶ãÂïèÁ≠îÊàñÂñÆ‰∏ÄÊï∏ÊìöÊü•Ë©¢Ôºâ
                    </div>
                </div>

                <!-- Chat Container for Free Conversation Mode -->
                <div class="chat-container" id="chatContainer">
                    <div class="chat-messages" id="chatMessages">
                        <!-- Chat messages will be populated dynamically -->
                    </div>
                    <div class="chat-loading" id="chatLoading">
                        <div class="chat-loading-spinner"></div>
                        <div>AI ÊÄùËÄÉ‰∏≠...</div>
                    </div>
                    <div class="chat-input-container" id="chatInputContainer" style="display: none;">
                        <!-- Input will be moved here in chat mode -->
                    </div>
                </div>

                <!-- Conversation History -->
                <div class="conversation-history" id="conversationHistory" style="display: none;">
                    <div class="conversation-history-header">Â∞çË©±Ë®òÈåÑ</div>
                    <div class="conversation-history-list" id="conversationHistoryList">
                        <!-- History items will be populated dynamically -->
                    </div>
                </div>

                <!-- AI Summary -->
                <div class="ai-summary" id="aiSummarySection" style="display: none;">
                    <div class="ai-summary-header">
                        ü§ñ AI ÁîüÊàêÊëòË¶Å
                    </div>
                    <div id="aiSummaryContent">
                        <!-- Summary will be populated dynamically from API -->
                    </div>
                </div>

                <!-- View Tabs -->
                <div class="view-tabs">
                    <button class="tab active" data-view="list">ÂàóË°®Ë¶ñÂúñ</button>
                    <button class="tab" data-view="timeline">ÊôÇÈñìËª∏Ë¶ñÂúñ</button>
                </div>

                <!-- Summary Toggle (for both list and timeline views) -->
                <div class="summary-toggle active" id="summaryToggle">
                    <button class="btn-toggle-summary" id="btnToggleSummary">üìù Â±ïÈñãÊëòË¶Å</button>
                </div>

                <!-- Summary Loading -->
                <div class="summary-loading" id="summaryLoading">
                    ü§ñ ÊëòË¶ÅÁîüÊàê‰∏≠...
                </div>

                <!-- List View -->
                <div class="news-list" id="listView">
                    <!-- News cards will be populated dynamically from API -->
                </div>

                <!-- Timeline View -->
                <div class="timeline-view" id="timelineView">
                    <!-- Timeline items will be populated dynamically from API -->
                </div>

                <!-- Bottom Actions -->
                <div class="bottom-actions">
                    <button class="btn-action btn-share" id="btnShare">üîó ÂàÜ‰∫´ÁµêÊûú</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Share Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-header">üîó ÂàÜ‰∫´ÈÄôÂÄãÊêúÂ∞ãÁµêÊûú</div>
            <div class="modal-content">
                <div class="modal-description">Â∞áÊêúÂ∞ãÁµêÊûúË§áË£ΩÂà∞Ôºö</div>
                <div class="copy-options">
                    <button class="btn-copy" id="btnCopyPlainText">üìã Ë§áË£ΩÊëòË¶ÅÊñáÂ≠ó</button>
                    <button class="btn-copy" id="btnCopyChatGPT">ü§ñ Ë§áË£Ω‰∏¶ÈñãÂïü ChatGPT</button>
                    <button class="btn-copy" id="btnCopyClaude">üßë‚Äçüíª Ë§áË£Ω‰∏¶ÈñãÂïü Claude</button>
                    <button class="btn-copy" id="btnCopyGemini">üíé Ë§áË£Ω‰∏¶ÈñãÂïü Gemini</button>
                    <button class="btn-copy" id="btnCopyNotebookLM">üìì Ë§áË£Ω‰∏¶ÈñãÂïü NotebookLM</button>
                </div>
                <div class="modal-tip">
                    üí° ÂÖßÂÆπÂ∑≤ÂåÖÂê´ÊêúÂ∞ãÁµêÊûúÂíåËá™Áî±Â∞çË©±Á¥ÄÈåÑ
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn-close-modal" id="btnCloseModal">ÈóúÈñâ</button>
            </div>
        </div>
    </div>

    <!-- My Searches Modal -->
    <div class="modal-overlay" id="mySearchesModal">
        <div class="modal modal-large">
            <div class="modal-header">üìö ÊàëÁöÑÊêúÂ∞ã</div>
            <div class="modal-content">
                <div class="saved-sessions-list" id="savedSessionsList">
                    <!-- Saved sessions will be populated dynamically -->
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn-close-modal" id="btnCloseMySearches">ÈóúÈñâ</button>
            </div>
        </div>
    </div>

    <!-- Analytics Tracker -->
    <script src="/static/analytics-tracker-sse.js"></script>

    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>

    <script>
        const searchInput = document.getElementById('searchInput');
        const btnSearch = document.getElementById('btnSearch');
        const initialState = document.getElementById('initialState');
        const loadingState = document.getElementById('loadingState');
        const resultsSection = document.getElementById('resultsSection');
        const listView = document.getElementById('listView');
        const timelineView = document.getElementById('timelineView');
        const btnShare = document.getElementById('btnShare');
        const modalOverlay = document.getElementById('modalOverlay');
        const btnCloseModal = document.getElementById('btnCloseModal');
        const summaryToggle = document.getElementById('summaryToggle');
        const btnToggleSummary = document.getElementById('btnToggleSummary');
        const summaryLoading = document.getElementById('summaryLoading');
        const btnMySearches = document.getElementById('btnMySearches');
        const mySearchesModal = document.getElementById('mySearchesModal');
        const btnCloseMySearches = document.getElementById('btnCloseMySearches');
        const savedSessionsList = document.getElementById('savedSessionsList');
        const modeToggle = document.getElementById('modeToggle');
        const modeButtons = document.querySelectorAll('.mode-button');
        const chatContainer = document.getElementById('chatContainer');
        const chatMessagesEl = document.getElementById('chatMessages');
        const searchContainer = document.getElementById('searchContainer');
        const chatInputContainer = document.getElementById('chatInputContainer');
        const chatLoading = document.getElementById('chatLoading');

        let summaryExpanded = false;
        let summaryGenerated = false;

        // Conversation history tracking
        let conversationHistory = [];

        // Store complete session data for each query (query, answer, articles)
        let sessionHistory = [];

        // Store all saved sessions (when user clicks "Êñ∞Â∞çË©±")
        // Load from localStorage on startup
        let savedSessions = [];
        try {
            const stored = localStorage.getItem('taiwanNewsSavedSessions');
            if (stored) {
                savedSessions = JSON.parse(stored);
                console.log(`Loaded ${savedSessions.length} saved sessions from localStorage`);
            }
        } catch (e) {
            console.error('Failed to load saved sessions from localStorage:', e);
        }

        // Track the current loaded session ID to prevent duplicate saves
        let currentLoadedSessionId = null;

        // Mode tracking: 'search', 'deep_research', or 'chat'
        let currentMode = 'search';

        // ==================== ANALYTICS INITIALIZATION ====================
        const analyticsTracker = new AnalyticsTrackerSSE('/api/analytics/event');
        let currentAnalyticsQueryId = null;

        // Track current conversation ID for multi-turn conversations
        let currentConversationId = null;

        // Event delegation: Track all clicks on article links (left, middle, right)
        const handleLinkClick = (event) => {
            const link = event.target.closest('.btn-read-more, a[href]');
            if (!link) return;

            const newsCard = link.closest('.news-card');
            if (!newsCard) return;

            const url = link.href;
            const allCards = document.querySelectorAll('.news-card');
            const position = Array.from(allCards).indexOf(newsCard);

            if (currentAnalyticsQueryId && url) {
                analyticsTracker.trackClick(url, position);
            }
        };

        // Listen for all types of clicks
        document.addEventListener('click', handleLinkClick);        // Left click
        document.addEventListener('auxclick', handleLinkClick);     // Middle click
        document.addEventListener('contextmenu', handleLinkClick);  // Right click

        // MutationObserver: Auto-track article displays
        const articleObserver = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1 && node.classList && node.classList.contains('news-card')) {
                        const link = node.querySelector('a[href]');
                        if (link && currentAnalyticsQueryId) {
                            const allCards = document.querySelectorAll('.news-card');
                            const position = Array.from(allCards).indexOf(node);
                            const url = link.href;

                            analyticsTracker.trackResultDisplayed(url, position, {
                                title: node.querySelector('.news-title')?.textContent || ''
                            });

                            node.dataset.analyticsUrl = url;
                            node.dataset.analyticsPosition = position;
                            analyticsTracker.observeResult(node);
                        }
                    }
                });
            });
        });

        articleObserver.observe(document.getElementById('listView'), { childList: true, subtree: true });
        articleObserver.observe(document.getElementById('timelineView'), { childList: true, subtree: true });

        console.log('[Analytics] Tracker initialized');
        // ==================== END ANALYTICS INITIALIZATION ====================

        // Chat history for free conversation mode
        let chatHistory = [];

        // Accumulated articles from ALL searches in this conversation
        let accumulatedArticles = [];

        // Mode Toggle handler - Handle three modes
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                const newMode = button.dataset.mode;

                // Don't do anything if clicking the current mode
                if (newMode === currentMode) return;

                // Update button states
                modeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // Update current mode
                const previousMode = currentMode;
                currentMode = newMode;

                // Handle mode-specific UI changes
                if (newMode === 'search' || newMode === 'deep_research') {
                    // Both search modes use similar UI
                    btnSearch.textContent = 'ÊêúÂ∞ã';
                    searchInput.placeholder = newMode === 'deep_research'
                        ? 'Ëº∏ÂÖ•ÂïèÈ°åÈÄ≤Ë°åÊ∑±Â∫¶Á†îÁ©∂ÂàÜÊûê...'
                        : 'ÂïèÊàë‰ªª‰ΩïÊñ∞ËÅûÁõ∏ÈóúÂïèÈ°åÔºå‰æãÂ¶ÇÔºöÊúÄËøëÂè∞ÁÅ£Ë≥áÂÆâÊîøÁ≠ñÊúâ‰ªÄÈ∫ºÈÄ≤Â±ïÔºü';

                    // Move search container back to original position if coming from chat
                    if (previousMode === 'chat') {
                        const mainContainer = document.querySelector('main .container');
                        const loadingState = document.getElementById('loadingState');
                        mainContainer.insertBefore(searchContainer, loadingState);
                        chatInputContainer.style.display = 'none';
                        chatContainer.classList.remove('active');
                    }
                } else if (newMode === 'chat') {
                    // Chat mode
                    btnSearch.textContent = 'ÁôºÈÄÅ';
                    searchInput.placeholder = 'ÁπºÁ∫åÂ∞çË©±...';

                    // Show results section and chat container
                    resultsSection.classList.add('active');
                    chatContainer.classList.add('active');
                    chatInputContainer.appendChild(searchContainer);
                    chatInputContainer.style.display = 'block';
                }

                // Show/hide research mode selector and KG toggle based on mode
                const researchModeSelector = document.getElementById('researchModeSelector');
                const kgToggleContainer = document.getElementById('kgToggleContainer');
                if (newMode === 'deep_research') {
                    researchModeSelector.style.display = 'block';
                    kgToggleContainer.style.display = 'block';
                } else {
                    researchModeSelector.style.display = 'none';
                    kgToggleContainer.style.display = 'none';
                }
            });
        });

        // Research Mode Selection Handler
        const researchModeOptions = document.querySelectorAll('.research-mode-option');
        let currentResearchMode = 'discovery'; // Default mode

        researchModeOptions.forEach(option => {
            option.addEventListener('click', () => {
                // Update button states
                researchModeOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');

                // Update current research mode
                currentResearchMode = option.dataset.researchMode;
                console.log('[Research Mode] Selected:', currentResearchMode);
            });
        });

        // New Thread button handler
        const btnNewThread = document.getElementById('btnNewThread');
        btnNewThread.addEventListener('click', () => {
            // Save current session if there's any data
            if (sessionHistory.length > 0) {
                // Check if this session is already saved (either loaded or previously saved)
                const existingSessionIndex = currentLoadedSessionId !== null
                    ? savedSessions.findIndex(s => s.id === currentLoadedSessionId)
                    : -1;

                if (existingSessionIndex !== -1) {
                    // Update existing session instead of creating duplicate
                    savedSessions[existingSessionIndex] = {
                        id: currentLoadedSessionId,
                        title: conversationHistory[0] || 'Êú™ÂëΩÂêçÊêúÂ∞ã',
                        conversationHistory: [...conversationHistory],
                        sessionHistory: [...sessionHistory],
                        chatHistory: [...chatHistory],
                        accumulatedArticles: [...accumulatedArticles],
                        createdAt: savedSessions[existingSessionIndex].createdAt,
                        updatedAt: Date.now()
                    };
                    console.log('Session updated:', savedSessions[existingSessionIndex]);
                } else {
                    // Create new session
                    const currentSession = {
                        id: Date.now(),
                        title: conversationHistory[0] || 'Êú™ÂëΩÂêçÊêúÂ∞ã',
                        conversationHistory: [...conversationHistory],
                        sessionHistory: [...sessionHistory],
                        chatHistory: [...chatHistory],
                        accumulatedArticles: [...accumulatedArticles],
                        createdAt: Date.now()
                    };
                    savedSessions.push(currentSession);
                    console.log('Session saved:', currentSession);
                }

                // Persist to localStorage
                try {
                    localStorage.setItem('taiwanNewsSavedSessions', JSON.stringify(savedSessions));
                    console.log('Saved sessions persisted to localStorage');
                } catch (e) {
                    console.error('Failed to save sessions to localStorage:', e);
                }
            }

            // Clear conversation history and session data
            conversationHistory = [];
            sessionHistory = [];
            accumulatedArticles = []; // Clear accumulated articles
            chatHistory = []; // Clear chat history
            currentLoadedSessionId = null; // Reset loaded session ID
            currentConversationId = null; // Reset conversation ID for new conversation

            // Reset free conversation mode to search mode
            if (currentMode === 'chat') {
                currentMode = 'search';
                modeButtons.forEach(btn => btn.classList.remove('active')); modeButtons[0].classList.add('active');
                btnSearch.textContent = 'ÊêúÂ∞ã';
                searchInput.placeholder = 'ÊêúÂ∞ãÂè∞ÁÅ£Êñ∞ËÅû...';

                // Move search container back to original position
                const mainContainer = document.querySelector('main .container');
                const loadingStateEl = document.getElementById('loadingState');
                mainContainer.insertBefore(searchContainer, loadingStateEl);
                chatInputContainer.style.display = 'none';

                // Hide and clear chat container
                chatContainer.classList.remove('active');
                chatMessagesEl.innerHTML = '';
            }

            // Reset UI to initial state
            initialState.style.display = 'block';
            resultsSection.classList.remove('active');
            loadingState.classList.remove('active');

            // Clear search input
            searchInput.value = '';

            // Update UI to reflect cleared history
            renderConversationHistory();

            // Visual feedback
            const originalHTML = btnNewThread.innerHTML;
            btnNewThread.innerHTML = '<span>‚úì</span><span>Â∑≤ÂÑ≤Â≠ò</span>';
            btnNewThread.style.borderColor = '#059669';
            btnNewThread.style.color = '#059669';

            setTimeout(() => {
                btnNewThread.innerHTML = originalHTML;
                btnNewThread.style.borderColor = '';
                btnNewThread.style.color = '';
            }, 1500);
        });

        // Function to render conversation history
        function renderConversationHistory() {
            const historyContainer = document.getElementById('conversationHistory');
            const historyList = document.getElementById('conversationHistoryList');

            if (conversationHistory.length === 0) {
                // Hide if no history
                historyContainer.style.display = 'none';
                return;
            }

            // Show and populate history
            historyContainer.style.display = 'block';
            historyList.innerHTML = '';

            conversationHistory.forEach((query, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'conversation-history-item';
                historyItem.innerHTML = `
                    <span class="conversation-number">${index + 1}.</span>
                    <span class="conversation-text">${escapeHTML(query)}</span>
                `;

                // Add click handler to restore this session
                historyItem.addEventListener('click', () => {
                    restoreSession(index);
                });

                historyList.appendChild(historyItem);
            });
        }

        // Function to restore a previous session
        function restoreSession(sessionIndex) {
            if (sessionIndex >= 0 && sessionIndex < sessionHistory.length) {
                const session = sessionHistory[sessionIndex];
                console.log('Restoring session:', session);

                // Populate UI with the stored session data
                populateResultsFromAPI(session.data, session.query);

                // Show results section
                resultsSection.classList.add('active');

                // Scroll to results
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        // Function to handle streaming SSE requests
        async function handleStreamingRequest(url, query) {
            return new Promise((resolve, reject) => {
                const eventSource = new EventSource(url);
                let accumulatedData = {};
                let memoryNotifications = [];

                eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('SSE message received:', data);

                        // Handle different message types
                        switch(data.message_type) {
                            case 'begin-nlweb-response':
                                // Query started - capture query_id and conversation_id
                                if (data.query_id) {
                                    currentAnalyticsQueryId = data.query_id;
                                    analyticsTracker.startQuery(currentAnalyticsQueryId, data.query);
                                    console.log('[Analytics] Using backend query_id:', currentAnalyticsQueryId);
                                }
                                if (data.conversation_id) {
                                    currentConversationId = data.conversation_id;
                                    console.log('[Conversation] Using backend conversation_id:', currentConversationId);
                                }
                                break;

                            case 'remember':
                                // Memory request detected!
                                if (data.item_to_remember) {
                                    showMemoryNotification(data.item_to_remember);
                                    memoryNotifications.push(data.item_to_remember);
                                }
                                break;

                            case 'intermediate_result':
                                // Deep Research progress update
                                updateReasoningProgress(data);
                                break;

                            case 'clarification_required':
                                // Phase 4: Clarification needed before proceeding
                                console.log('[Clarification] Request received:', data.clarification);
                                showClarificationModal(data.clarification, data.query, eventSource);
                                break;

                            case 'complete':
                                // Stream complete, close connection
                                console.log('Stream complete. Accumulated data:', accumulatedData);
                                eventSource.close();
                                resolve(accumulatedData);
                                break;

                            default:
                                // Accumulate other data (nlws, etc.)
                                console.log('Accumulating data:', data);
                                Object.assign(accumulatedData, data);
                                console.log('Accumulated so far:', accumulatedData);
                                break;
                        }
                    } catch (e) {
                        console.error('Error parsing SSE message:', e);
                    }
                };

                eventSource.onerror = (error) => {
                    console.error('SSE error:', error);
                    eventSource.close();
                    // Resolve with whatever we have so far
                    resolve(accumulatedData);
                };
            });
        }

        // Function to update Deep Research progress display
        function updateReasoningProgress(data) {
            console.log('[Progress] updateReasoningProgress called with stage:', data.stage);
            let container = document.getElementById('reasoning-progress');

            // Create container if doesn't exist
            if (!container) {
                console.log('[Progress] Creating new progress container');
                container = document.createElement('div');
                container.id = 'reasoning-progress';
                container.className = 'reasoning-progress-container';
                container.innerHTML = `
                    <div class="progress-header">üî¨ Deep Research Progress</div>
                    <div class="progress-stages">
                        <div class="stage" id="stage-analyst">
                            <span class="icon">üìä</span>
                            <span class="label">Analyzing</span>
                            <span class="status"></span>
                        </div>
                        <div class="stage" id="stage-critic">
                            <span class="icon">üîç</span>
                            <span class="label">Reviewing</span>
                            <span class="status"></span>
                        </div>
                        <div class="stage" id="stage-writer">
                            <span class="icon">‚úçÔ∏è</span>
                            <span class="label">Writing</span>
                            <span class="status"></span>
                        </div>
                    </div>
                    <div class="progress-details"></div>
                `;

                // Insert into loading state (which is visible during Deep Research)
                const loadingState = document.getElementById('loadingState');
                if (loadingState) {
                    loadingState.appendChild(container);
                } else {
                    // Fallback: Insert before results
                    const resultsSection = document.getElementById('results');
                    if (resultsSection) {
                        resultsSection.insertBefore(container, resultsSection.firstChild);
                    }
                }
            }

            // Update stage status
            const stage = data.stage;
            const details = container.querySelector('.progress-details');

            // Use user_message from backend if available (Phase 1)
            const userMessage = data.user_message || null;
            const progress = data.progress || null;

            if (stage === 'analyst_analyzing') {
                const stageEl = document.getElementById('stage-analyst');
                console.log('[Progress] stage-analyst element:', stageEl);
                if (stageEl) {
                    stageEl.classList.add('active');
                    // Use user_message if available, otherwise fallback to English
                    const message = userMessage || `Iteration ${data.iteration}/${data.total_iterations}: Analyzing sources...`;
                    if (details) {
                        details.textContent = message;
                        if (progress !== null) details.textContent += ` (${progress}%)`;
                    }
                } else {
                    console.error('[Progress] stage-analyst element not found!');
                }
            } else if (stage === 'analyst_complete') {
                const stageEl = document.getElementById('stage-analyst');
                if (stageEl) {
                    stageEl.classList.remove('active');
                    stageEl.classList.add('complete');
                    const statusEl = stageEl.querySelector('.status');
                    if (statusEl) statusEl.textContent = `‚úì ${data.citations_count || 0} sources`;
                }
                // Update details with user_message if available
                if (details && userMessage) {
                    details.textContent = userMessage;
                    if (progress !== null) details.textContent += ` (${progress}%)`;
                }
            } else if (stage === 'gap_search_started') {
                // Phase 5: Gap Detection - Secondary search in progress
                const stageEl = document.getElementById('stage-analyst');
                if (stageEl && details) {
                    stageEl.classList.add('active');
                    stageEl.classList.remove('complete');
                    const queryList = data.new_queries ? data.new_queries.map(q => `„Äå${q}„Äç`).join(', ') : '';
                    details.innerHTML = `
                        <div style="color: #f59e0b; font-weight: 500;">üîç ${userMessage || 'Ê≠£Âú®Ë£úÂÖÖÊêúÂ∞ã...'}</div>
                        <div style="font-size: 11px; margin-top: 4px; color: #64748b;">
                            ${data.gap_reason || 'ÁôºÁèæË≥áË®äÁº∫Âè£'}
                        </div>
                        ${queryList ? `<div style="font-size: 10px; margin-top: 2px; color: #94a3b8;">Êü•Ë©¢Ôºö${queryList}</div>` : ''}
                    `;
                }
            } else if (stage === 'critic_reviewing') {
                const stageEl = document.getElementById('stage-critic');
                if (stageEl) {
                    stageEl.classList.add('active');
                    // Use user_message if available, otherwise fallback to English
                    const message = userMessage || 'Reviewing draft for quality and compliance...';
                    if (details) {
                        details.textContent = message;
                        if (progress !== null) details.textContent += ` (${progress}%)`;
                    }
                }
            } else if (stage === 'critic_complete') {
                const stageEl = document.getElementById('stage-critic');
                if (stageEl) {
                    stageEl.classList.remove('active');
                    stageEl.classList.add('complete');
                    const emoji = data.status === 'PASS' ? '‚úÖ' : data.status === 'WARN' ? '‚ö†Ô∏è' : '‚ùå';
                    const statusEl = stageEl.querySelector('.status');
                    if (statusEl) statusEl.textContent = `${emoji} ${data.status}`;
                }
                // Update details with user_message if available
                if (details && userMessage) {
                    details.textContent = userMessage;
                    if (progress !== null) details.textContent += ` (${progress}%)`;
                }
            } else if (stage === 'writer_planning') {
                // Phase 3: Writer planning stage
                const stageEl = document.getElementById('stage-writer');
                if (stageEl) {
                    stageEl.classList.add('active');
                    const message = userMessage || 'Planning report structure...';
                    if (details) {
                        details.textContent = message;
                        if (progress !== null) details.textContent += ` (${progress}%)`;
                    }
                }
            } else if (stage === 'writer_composing') {
                const stageEl = document.getElementById('stage-writer');
                if (stageEl) {
                    stageEl.classList.add('active');
                    // Use user_message if available, otherwise fallback to English
                    const message = userMessage || 'Composing final report...';
                    if (details) {
                        details.textContent = message;
                        if (progress !== null) details.textContent += ` (${progress}%)`;
                    }
                }
            } else if (stage === 'writer_complete') {
                const stageEl = document.getElementById('stage-writer');
                if (stageEl) {
                    stageEl.classList.remove('active');
                    stageEl.classList.add('complete');
                    const statusEl = stageEl.querySelector('.status');
                    if (statusEl) statusEl.textContent = '‚úì Done';
                    // Use user_message if available, otherwise fallback to English
                    const message = userMessage || '‚úÖ Research complete!';
                    if (details) details.textContent = message;
                }
            }
        }

        // Function to show memory notification
        function showMemoryNotification(itemToRemember) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'memory-notification';
            notification.innerHTML = `
                <span class="memory-icon">üíæ</span>
                <span class="memory-text">ÊàëÊúÉË®ò‰ΩèÔºö„Äå${escapeHTML(itemToRemember)}„Äç</span>
            `;

            // Add to results section or create a notification area
            let notificationArea = document.getElementById('memoryNotificationArea');
            if (!notificationArea) {
                notificationArea = document.createElement('div');
                notificationArea.id = 'memoryNotificationArea';
                notificationArea.style.cssText = 'margin-bottom: 20px;';
                resultsSection.insertBefore(notificationArea, resultsSection.firstChild);
            }

            notificationArea.appendChild(notification);

            // Auto-hide after 5 seconds with fade out
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 5000);
        }

        // Function to populate UI from API response
        function populateResultsFromAPI(data, query) {
            // Get articles from response - prioritize content/results for summarize mode
            const articles = data.content || data.results || (data.nlws && data.nlws.items) || [];

            // Populate AI Summary section at the top
            const aiSummarySection = document.getElementById('aiSummarySection');
            const aiSummaryContent = document.getElementById('aiSummaryContent');

            if (data.summary && data.summary.message) {
                // We have a summary (from summarize mode)
                aiSummaryContent.innerHTML = `
                    <div class="summary-section">
                        <div class="summary-content">${escapeHTML(data.summary.message)}</div>
                    </div>
                    <div class="summary-footer">
                        <div class="source-info">‚ö†Ô∏è Ë≥áÊñô‰æÜÊ∫êÔºöÂü∫Êñº ${articles.length} ÂâáÂ†±Â∞éÁîüÊàê</div>
                        <div class="feedback-buttons">
                            <button class="btn-feedback">üëç ÊúâÂπ´Âä©</button>
                            <button class="btn-feedback">üëé ‰∏çÊ∫ñÁ¢∫</button>
                        </div>
                    </div>
                `;
                aiSummarySection.style.display = 'block';
            } else if (data.nlws && data.nlws.answer) {
                // We have an AI-generated answer (from generate mode)
                // Convert markdown links to HTML and preserve <br> tags for proper rendering
                const formattedAnswer = convertMarkdownToHtml(data.nlws.answer);
                aiSummaryContent.innerHTML = `
                    <div class="summary-section">
                        <div class="summary-content">${formattedAnswer}</div>
                    </div>
                    <div class="summary-footer">
                        <div class="source-info">‚ö†Ô∏è Ë≥áÊñô‰æÜÊ∫êÔºöÂü∫Êñº ${articles.length} ÂâáÂ†±Â∞éÁîüÊàê</div>
                        <div class="feedback-buttons">
                            <button class="btn-feedback">üëç ÊúâÂπ´Âä©</button>
                            <button class="btn-feedback">üëé ‰∏çÊ∫ñÁ¢∫</button>
                        </div>
                    </div>
                `;
                aiSummarySection.style.display = 'block';
            } else {
                aiSummarySection.style.display = 'none';
            }

            // Clear existing list view content
            listView.innerHTML = '';
            timelineView.innerHTML = '';

            if (articles.length === 0) {
                listView.innerHTML = '<div class="news-card"><div class="news-title">Ê≤íÊúâÊâæÂà∞Áõ∏ÈóúÊñáÁ´†</div></div>';
                console.warn('No articles found in API response');
                return;
            }

            // Group articles by date for timeline view
            const articlesByDate = {};

            // Sort articles by score in descending order (highest score first)
            articles.sort((a, b) => {
                const scoreA = a.score || a.metadata?.score || 0;
                const scoreB = b.score || b.metadata?.score || 0;
                return scoreB - scoreA;
            });

            // Populate news cards
            articles.forEach((article, index) => {
                const schema = article.schema_object || article;
                // Score might be at article.score or article.metadata.score
                let rawScore = article.score || article.metadata?.score || 0;

                // If score is > 1, it's already a percentage (e.g., 85)
                // If score is <= 1, it's a decimal (e.g., 0.85) and needs to be multiplied by 100
                const relevancePercent = rawScore > 1 ? Math.round(rawScore) : Math.round(rawScore * 100);

                // For star calculation, normalize to 0-1 range
                const normalizedScore = rawScore > 1 ? rawScore / 100 : rawScore;
                const stars = Math.min(5, Math.max(1, Math.round(normalizedScore * 5)));
                const starsHTML = '‚òÖ'.repeat(stars) + '‚òÜ'.repeat(5 - stars);

                // Extract data with fallbacks
                const title = schema.headline || schema.name || 'ÁÑ°Ê®ôÈ°å';

                // Try multiple locations for publisher/source
                let publisher = 'Êú™Áü•‰æÜÊ∫ê';
                if (schema.publisher?.name) {
                    publisher = schema.publisher.name;
                } else if (schema.publisher && typeof schema.publisher === 'string') {
                    publisher = schema.publisher;
                } else if (article.site) {
                    // Use the site field if available (e.g., "ithome")
                    publisher = article.site.charAt(0).toUpperCase() + article.site.slice(1); // Capitalize first letter
                } else if (schema.author) {
                    if (Array.isArray(schema.author) && schema.author.length > 0) {
                        publisher = schema.author[0].name || schema.author[0];
                    } else if (typeof schema.author === 'string') {
                        publisher = schema.author;
                    }
                }

                const datePublished = schema.datePublished || new Date().toISOString();
                const date = new Date(datePublished).toISOString().split('T')[0];
                const description = schema.description || article.description || '';
                const url = schema.url || '#';

                // Create card for list view
                const cardHTML = `
                    <div class="news-card">
                        <div class="news-title">${escapeHTML(title)}</div>
                        <div class="news-meta">
                            <span>üè¢ ${escapeHTML(publisher)}</span>
                            <span>üìÖ ${date}</span>
                            <div class="relevance">
                                <span class="stars">${starsHTML}</span>
                                <span>Áõ∏ÈóúÂ∫¶ ${relevancePercent}%</span>
                            </div>
                        </div>
                        ${description ? `<div class="news-excerpt">${escapeHTML(description)}</div>` : ''}
                        <a href="${escapeHTML(url)}" class="btn-read-more" target="_blank">Èñ±ËÆÄÂÖ®Êñá ‚Üí</a>
                    </div>
                `;

                listView.innerHTML += cardHTML;

                // Group by date for timeline view
                if (!articlesByDate[date]) {
                    articlesByDate[date] = [];
                }
                articlesByDate[date].push({
                    title, publisher, description, url, starsHTML, relevancePercent
                });
            });

            // Populate timeline view
            const sortedDates = Object.keys(articlesByDate).sort().reverse();
            sortedDates.forEach(date => {
                const dateArticles = articlesByDate[date];
                const timelineHTML = `
                    <div class="timeline-date">
                        <div class="timeline-dot"></div>
                        <div class="date-label">${date}</div>
                        ${dateArticles.map(art => `
                            <div class="news-card">
                                <div class="news-title">${escapeHTML(art.title)}</div>
                                <div class="news-meta">
                                    <span>üè¢ ${escapeHTML(art.publisher)}</span>
                                    <div class="relevance">
                                        <span class="stars">${art.starsHTML}</span>
                                        <span>Áõ∏ÈóúÂ∫¶ ${art.relevancePercent}%</span>
                                    </div>
                                </div>
                                ${art.description ? `<div class="news-excerpt">${escapeHTML(art.description)}</div>` : ''}
                                <a href="${escapeHTML(art.url)}" class="btn-read-more" target="_blank">Èñ±ËÆÄÂÖ®Êñá ‚Üí</a>
                            </div>
                        `).join('')}
                    </div>
                `;
                timelineView.innerHTML += timelineHTML;
            });
        }

        // Helper function to escape HTML
        function escapeHTML(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Convert markdown-style links to HTML and preserve HTML line breaks
        // Converts [‰æÜÊ∫ê](url) to clickable <a> tags while keeping <br> tags
        function convertMarkdownToHtml(text) {
            if (!text) return '';

            // First escape any potentially dangerous HTML except <br> tags
            let safe = text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");

            // Restore <br> tags
            safe = safe.replace(/&lt;br&gt;/g, "<br>");

            // Convert markdown links [text](url) to HTML <a> tags
            // Pattern: [any text](url)
            safe = safe.replace(/\[([^\]]+)\]\(([^)]+)\)/g, function(match, text, url) {
                // Decode HTML entities in the URL that we encoded earlier
                const decodedUrl = url
                    .replace(/&amp;/g, "&")
                    .replace(/&lt;/g, "<")
                    .replace(/&gt;/g, ">");

                return `<a href="${decodedUrl}" class="source-link" target="_blank" rel="noopener noreferrer">${text}</a>`;
            });

            return safe;
        }

        // Search functionality
        btnSearch.addEventListener('click', performSearch);
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                performSearch();
            }
        });

        async function performSearch() {
            const query = searchInput.value.trim();
            if (!query) return;

            // Note: Analytics will be initialized when we receive 'begin-nlweb-response' from backend
            // with the server-generated query_id

            // Hide initial state
            initialState.style.display = 'none';

            // Check current mode
            if (currentMode === 'chat') {
                // Free conversation mode - no search, just chat
                await performFreeConversation(query);
                return;
            }

            if (currentMode === 'deep_research') {
                // Deep Research mode - use Actor-Critic reasoning
                await performDeepResearch(query);
                return;
            }

            // Search mode - normal flow
            // Show loading
            loadingState.classList.add('active');
            resultsSection.classList.remove('active');

            try {
                const base = window.location.origin;

                // Capture conversation history BEFORE this query (for context)
                const prevQueriesForThisTurn = [...conversationHistory];

                // Make TWO API calls to get both summary and scores
                // Call 1: Get articles with relevance scores using 'summarize' mode
                const summarizeUrl = new URL('/ask', base);
                summarizeUrl.searchParams.append('query', query);
                summarizeUrl.searchParams.append('site', 'all');
                summarizeUrl.searchParams.append('generate_mode', 'summarize');
                summarizeUrl.searchParams.append('streaming', 'false');
                // Send conversation history for context
                if (prevQueriesForThisTurn.length > 0) {
                    summarizeUrl.searchParams.append('prev', JSON.stringify(prevQueriesForThisTurn));
                }

                const summarizeResponse = await fetch(summarizeUrl.toString());
                if (!summarizeResponse.ok) {
                    throw new Error(`API error: ${summarizeResponse.statusText}`);
                }

                let summarizeData = await summarizeResponse.json();
                if (Array.isArray(summarizeData) && summarizeData.length > 0) {
                    summarizeData = summarizeData[0];
                }

                // Extract parent_query_id from summarize response for analytics linking
                const parentQueryId = summarizeData.query_id || summarizeData.conversation_id;

                // Call 2: Get AI-generated summary using 'generate' mode with STREAMING
                // This allows us to receive memory messages in real-time
                const generateUrl = new URL('/ask', base);
                generateUrl.searchParams.append('query', query);
                generateUrl.searchParams.append('site', 'all');
                generateUrl.searchParams.append('generate_mode', 'generate');
                generateUrl.searchParams.append('streaming', 'true'); // Enable streaming for memory messages
                if (parentQueryId) {
                    generateUrl.searchParams.append('parent_query_id', parentQueryId);
                }
                // Send conversation history for context
                if (prevQueriesForThisTurn.length > 0) {
                    generateUrl.searchParams.append('prev', JSON.stringify(prevQueriesForThisTurn));
                }

                let generateData = await handleStreamingRequest(generateUrl.toString(), query);

                // Debug logging
                console.log('Generate Data received:', generateData);
                console.log('Generate Data answer:', generateData.answer);
                console.log('Summarize Data:', summarizeData);

                // Combine both: use articles with scores from summarize, and AI answer from generate
                // The SSE stream returns answer directly in the data object, not nested under nlws
                const combinedData = {
                    content: summarizeData.content || [], // Articles with scores
                    nlws: generateData.answer ? { answer: generateData.answer } : null, // AI summary - wrap answer in nlws format
                    summary: summarizeData.summary || null
                };

                console.log('Combined Data:', combinedData);

                // Parse and populate the UI with combined data
                populateResultsFromAPI(combinedData, query);

                // Store complete session data for this query
                sessionHistory.push({
                    query: query,
                    data: combinedData,
                    timestamp: Date.now()
                });

                // Accumulate articles from this search for chat mode
                if (combinedData.content && combinedData.content.length > 0) {
                    // Add new articles, avoiding duplicates by URL
                    const existingUrls = new Set(accumulatedArticles.map(art => art.url || art.schema_object?.url));
                    const newArticles = combinedData.content.filter(art => {
                        const url = art.url || art.schema_object?.url;
                        return url && !existingUrls.has(url);
                    });
                    accumulatedArticles.push(...newArticles);
                    console.log(`Accumulated ${newArticles.length} new articles, total: ${accumulatedArticles.length}`);
                }

                // Add current query to history for NEXT turn
                conversationHistory.push(query);
                // Keep only last 10 queries
                if (conversationHistory.length > 10) {
                    conversationHistory.shift();
                    // Also trim sessionHistory to match
                    sessionHistory.shift();
                }

                // Update conversation history display
                renderConversationHistory();

                loadingState.classList.remove('active');
                resultsSection.classList.add('active');

                // Scroll to results
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } catch (error) {
                console.error('Search failed:', error);
                loadingState.classList.remove('active');
                alert('ÊêúÂ∞ãÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇError: ' + error.message);
            }
        }

        // Deep Research Mode function
        async function performDeepResearch(query, skipClarification = false, comprehensiveSearch = false) {
            console.log('=== Deep Research Mode ===');
            console.log('Query:', query);
            console.log('Skip clarification:', skipClarification);
            console.log('Comprehensive search:', comprehensiveSearch);

            // Save query before clearing (for conversation history)
            const savedQuery = query;

            // Clear input
            searchInput.value = '';

            // Enable chat container for conversational clarification
            const chatContainer = document.getElementById('chatContainer');
            const chatMessagesEl = document.getElementById('chatMessages');
            if (chatContainer) {
                // Show results section (parent of chat container)
                resultsSection.classList.add('active');
                chatContainer.classList.add('active');
                console.log('[Deep Research] Chat container activated');

                // Add user message to chat
                if (chatMessagesEl) {
                    const userMessageDiv = document.createElement('div');
                    userMessageDiv.className = 'chat-message user';
                    userMessageDiv.innerHTML = `
                        <div class="chat-message-header">‰Ω†</div>
                        <div class="chat-message-bubble">${escapeHTML(query)}</div>
                    `;
                    chatMessagesEl.appendChild(userMessageDiv);
                    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                    console.log('[Deep Research] User message added to chat');
                }
            }

            // Show loading
            loadingState.classList.add('active');

            try {
                const base = window.location.origin;

                // Call Deep Research API with SSE streaming
                const deepResearchUrl = new URL('/api/deep_research', base);
                deepResearchUrl.searchParams.append('query', query);
                deepResearchUrl.searchParams.append('site', 'all');
                deepResearchUrl.searchParams.append('research_mode', currentResearchMode); // User-selected mode
                deepResearchUrl.searchParams.append('max_iterations', '3');

                // Add skip_clarification flag (critical for avoiding infinite loops)
                if (skipClarification) {
                    deepResearchUrl.searchParams.append('skip_clarification', 'true');
                    console.log('[Deep Research] Skip clarification enabled');
                }

                // Add comprehensive_search flag for MMR tuning
                if (comprehensiveSearch) {
                    deepResearchUrl.searchParams.append('comprehensive_search', 'true');
                    console.log('[Deep Research] Comprehensive search enabled (high diversity)');
                }

                // Add enable_kg flag (Phase KG)
                const kgToggle = document.getElementById('kgToggle');
                if (kgToggle && kgToggle.checked) {
                    deepResearchUrl.searchParams.append('enable_kg', 'true');
                    console.log('[Deep Research] Knowledge Graph generation enabled');
                }

                // Add conversation_id for context continuity across modes
                if (currentConversationId) {
                    deepResearchUrl.searchParams.append('conversation_id', currentConversationId);
                    console.log('[Deep Research] Using existing conversation_id:', currentConversationId);
                }

                console.log('Deep Research URL:', deepResearchUrl.toString());

                // Use SSE streaming to get progress updates
                const eventSource = new EventSource(deepResearchUrl.toString());

                let fullReport = '';
                let progressContainer = null;

                eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('Deep Research SSE:', data);

                        // Handle different message types
                        if (data.message_type === 'begin-nlweb-response') {
                            // Query started - capture conversation_id
                            if (data.conversation_id) {
                                currentConversationId = data.conversation_id;
                                console.log('[Deep Research] Using backend conversation_id:', currentConversationId);
                            }
                        } else if (data.message_type === 'clarification_required') {
                            // Phase 4: Clarification needed before proceeding (conversational)
                            console.log('[Clarification] Request received:', data.clarification);
                            addClarificationMessage(data.clarification, data.query, eventSource, savedQuery);
                        } else if (data.message_type === 'intermediate_result') {
                            // Progress update - show reasoning progress
                            updateReasoningProgress(data);
                        } else if (data.message_type === 'final_result') {
                            // Final report received
                            fullReport = data.final_report || '';

                            // Close event source
                            eventSource.close();

                            // Hide loading
                            loadingState.classList.remove('active');

                            // Display results
                            displayDeepResearchResults(fullReport, data, savedQuery);
                        } else if (data.message_type === 'complete') {
                            // Stream complete - close connection
                            eventSource.close();
                            console.log('Deep Research stream complete');
                        } else if (data.message_type === 'error') {
                            console.error('Deep Research error:', data.error);
                            eventSource.close();
                            loadingState.classList.remove('active');
                            alert('Deep Research ÁôºÁîüÈåØË™§: ' + data.error);
                        }
                    } catch (e) {
                        console.error('Failed to parse SSE data:', e);
                    }
                };

                eventSource.onerror = (error) => {
                    console.error('SSE connection error:', error);
                    eventSource.close();
                    loadingState.classList.remove('active');
                    alert('Deep Research ÈÄ£Á∑öÈåØË™§');
                };

            } catch (error) {
                console.error('Deep Research error:', error);
                loadingState.classList.remove('active');
                alert('Deep Research ÁôºÁîüÈåØË™§: ' + error.message);
            }
        }

        // Helper function to convert citation numbers [1] to clickable links
        function addCitationLinks(htmlContent, sources) {
            if (!sources || sources.length === 0) {
                return htmlContent;
            }

            // Replace [1], [2], etc. with clickable links (handles both single [1] and consecutive [3][4][23])
            return htmlContent.replace(/\[(\d+)\]/g, (match, num) => {
                const index = parseInt(num) - 1;
                if (index >= 0 && index < sources.length) {
                    const url = sources[index];
                    if (url) {  // Only create link if URL is not empty
                        return `<a href="${url}" target="_blank" class="citation-link" title="‰æÜÊ∫ê ${num}">[${num}]</a>`;
                    }
                }
                return match; // Keep original if index out of range or URL is empty
            });
        }

        function displayDeepResearchResults(report, metadata, savedQuery) {
            console.log('[Deep Research] Displaying results');
            console.log('[Deep Research] Metadata received:', metadata);
            console.log('[Deep Research] Sources array:', metadata?.sources);
            console.log('[Deep Research] Sources count:', metadata?.sources?.length);

            // Extract schema_object from content (Deep Research sends results in content array)
            let schemaObj = null;
            console.log('[Deep Research] metadata.content:', metadata?.content);
            if (metadata?.content && Array.isArray(metadata.content) && metadata.content.length > 0) {
                console.log('[Deep Research] First content item:', metadata.content[0]);
                schemaObj = metadata.content[0].schema_object;
                console.log('[Deep Research] Extracted schema_object:', schemaObj);
            } else {
                console.log('[Deep Research] No content array found, trying direct access');
                // Try direct access for backward compatibility
                schemaObj = metadata?.schema_object;
                console.log('[Deep Research] Direct schema_object:', schemaObj);
            }

            // Show results section
            resultsSection.classList.add('active');

            // Display Knowledge Graph if available (Phase KG)
            displayKnowledgeGraph(schemaObj?.knowledge_graph || metadata?.knowledge_graph);

            // Clear and display report in listView (MUST be before displayReasoningChain!)
            listView.innerHTML = '';

            // Create report container
            const reportContainer = document.createElement('div');
            reportContainer.className = 'deep-research-report';
            reportContainer.style.cssText = 'padding: 20px; max-width: 900px; margin: 0 auto;';

            // Convert markdown to HTML
            let reportHTML = marked.parse(report || 'ÁÑ°ÁµêÊûú');

            // Add citation links if sources are available
            if (metadata && metadata.sources && metadata.sources.length > 0) {
                console.log('[Deep Research] Adding citation links with', metadata.sources.length, 'sources');
                reportHTML = addCitationLinks(reportHTML, metadata.sources);
            } else {
                console.warn('[Deep Research] No sources available for citation links');
            }

            reportContainer.innerHTML = reportHTML;
            listView.appendChild(reportContainer);

            // Display Reasoning Chain if available (Phase 4) - AFTER report is added
            displayReasoningChain(schemaObj?.argument_graph || metadata?.argument_graph,
                                 schemaObj?.reasoning_chain_analysis || metadata?.reasoning_chain_analysis);

            // Add to conversation history (use savedQuery parameter)
            if (savedQuery) {
                conversationHistory.push(savedQuery);
            }

            // Remove progress indicator
            const progressContainer = document.getElementById('reasoning-progress');
            if (progressContainer) {
                progressContainer.remove();
            }

            console.log('[Deep Research] Results displayed successfully');
        }

        // Knowledge Graph Display Functions (Phase KG Enhanced with D3.js)

        // Entity type colors for D3 visualization
        const KG_ENTITY_COLORS = {
            'person': '#3b82f6',      // blue
            'organization': '#8b5cf6', // purple
            'event': '#f59e0b',        // amber
            'location': '#10b981',     // emerald
            'metric': '#ef4444',       // red
            'technology': '#06b6d4',   // cyan
            'concept': '#6366f1',      // indigo
            'product': '#ec4899'       // pink
        };

        // Entity type labels
        const KG_TYPE_LABELS = {
            'person': '‰∫∫Áâ©',
            'organization': 'ÁµÑÁπî',
            'event': '‰∫ã‰ª∂',
            'location': 'Âú∞Èªû',
            'metric': 'ÊåáÊ®ô',
            'technology': 'ÊäÄË°ì',
            'concept': 'Ê¶ÇÂøµ',
            'product': 'Áî¢ÂìÅ'
        };

        // Relation type labels
        const KG_RELATION_LABELS = {
            'causes': 'Â∞éËá¥',
            'enables': '‰øÉÊàê',
            'prevents': 'ÈòªÊ≠¢',
            'precedes': 'ÂÖàÊñº',
            'concurrent': 'ÂêåÊôÇ',
            'part_of': 'Â±¨Êñº',
            'owns': 'ÊìÅÊúâ',
            'related_to': 'Áõ∏Èóú'
        };

        // Global KG data store for view switching
        let currentKGData = null;
        let kgSimulation = null;

        function displayKnowledgeGraph(kg) {
            const container = document.getElementById('kgDisplayContainer');
            const graphView = document.getElementById('kgGraphView');
            const listContent = document.getElementById('kgDisplayContent');
            const empty = document.getElementById('kgDisplayEmpty');
            const metadata = document.getElementById('kgMetadata');
            const legend = document.getElementById('kgLegend');

            if (!kg || (!kg.entities || kg.entities.length === 0)) {
                container.style.display = 'none';
                console.log('[KG] No knowledge graph data to display');
                return;
            }

            // Store KG data globally
            currentKGData = kg;

            // Show container
            container.style.display = 'block';

            // Update metadata
            const entityCount = kg.entities?.length || 0;
            const relCount = kg.relationships?.length || 0;
            const timestamp = kg.metadata?.generated_at ? new Date(kg.metadata.generated_at).toLocaleTimeString('zh-TW', {hour: '2-digit', minute: '2-digit'}) : '';
            metadata.textContent = `${entityCount} ÂÄãÂØ¶È´î ‚Ä¢ ${relCount} ÂÄãÈóú‰øÇ${timestamp ? ' ‚Ä¢ ÁîüÊàêÊñº ' + timestamp : ''}`;

            // Render list view content
            renderKGListView(kg, listContent);

            // Render graph view with D3
            renderKGGraphView(kg, graphView);

            // Render legend
            renderKGLegend(kg, legend);

            // Setup view toggle
            setupKGViewToggle();

            empty.style.display = 'none';
            console.log('[KG] Knowledge graph displayed successfully with D3 visualization');
        }

        function renderKGListView(kg, container) {
            let html = '';

            // Entities section
            if (kg.entities && kg.entities.length > 0) {
                html += '<div class="kg-section">';
                html += `<div class="kg-section-title">ÂØ¶È´î (${kg.entities.length})</div>`;
                kg.entities.forEach(entity => {
                    const typeLabel = KG_TYPE_LABELS[entity.entity_type] || entity.entity_type;
                    html += '<div class="kg-item">';
                    html += `<div><span class="kg-item-name">${escapeHTML(entity.name)}</span>`;
                    html += `<span class="kg-item-type">${typeLabel}</span>`;
                    html += `<span class="kg-item-confidence ${entity.confidence}">${entity.confidence}</span>`;
                    html += '</div>';
                    if (entity.description) {
                        html += `<div class="kg-item-desc">${escapeHTML(entity.description)}</div>`;
                    }
                    html += '</div>';
                });
                html += '</div>';
            }

            // Relationships section
            if (kg.relationships && kg.relationships.length > 0) {
                html += '<div class="kg-section">';
                html += `<div class="kg-section-title">Èóú‰øÇ (${kg.relationships.length})</div>`;

                const entityMap = {};
                if (kg.entities) {
                    kg.entities.forEach(e => entityMap[e.entity_id] = e.name);
                }

                kg.relationships.forEach(rel => {
                    const relationLabel = KG_RELATION_LABELS[rel.relation_type] || rel.relation_type;
                    const sourceName = entityMap[rel.source_entity_id] || 'Êú™Áü•';
                    const targetName = entityMap[rel.target_entity_id] || 'Êú™Áü•';

                    html += '<div class="kg-item">';
                    html += `<div>${escapeHTML(sourceName)} <span class="kg-relationship-arrow">‚Üí</span> ${escapeHTML(targetName)}`;
                    html += `<span class="kg-item-type">${relationLabel}</span>`;
                    html += `<span class="kg-item-confidence ${rel.confidence}">${rel.confidence}</span>`;
                    html += '</div>';
                    if (rel.description) {
                        html += `<div class="kg-item-desc">${escapeHTML(rel.description)}</div>`;
                    }
                    html += '</div>';
                });
                html += '</div>';
            }

            container.innerHTML = html;
        }

        function renderKGGraphView(kg, container) {
            // Clear previous SVG
            d3.select(container).select('svg').remove();

            // Preserve tooltip
            const tooltip = document.getElementById('kgTooltip');

            const width = container.clientWidth || 600;
            const height = container.clientHeight || 400;

            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Add zoom behavior
            const g = svg.append('g');
            const zoom = d3.zoom()
                .scaleExtent([0.3, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            svg.call(zoom);

            // Build entity map
            const entityMap = {};
            kg.entities.forEach(e => entityMap[e.entity_id] = e);

            // Prepare nodes and links for D3
            const nodes = kg.entities.map(e => ({
                id: e.entity_id,
                name: e.name,
                type: e.entity_type,
                description: e.description,
                confidence: e.confidence
            }));

            const nodeIds = new Set(nodes.map(n => n.id));
            const links = (kg.relationships || [])
                .filter(r => nodeIds.has(r.source_entity_id) && nodeIds.has(r.target_entity_id))
                .map(r => ({
                    source: r.source_entity_id,
                    target: r.target_entity_id,
                    type: r.relation_type,
                    description: r.description,
                    confidence: r.confidence
                }));

            // Create force simulation
            if (kgSimulation) {
                kgSimulation.stop();
            }

            kgSimulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(120))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(40));

            // Draw arrow markers for directed edges
            svg.append('defs').selectAll('marker')
                .data(['arrow'])
                .enter().append('marker')
                .attr('id', 'arrow')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 25)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('fill', '#94a3b8')
                .attr('d', 'M0,-5L10,0L0,5');

            // Draw links
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'kg-link')
                .attr('stroke', '#94a3b8')
                .attr('stroke-width', 2)
                .attr('marker-end', 'url(#arrow)');

            // Draw link labels
            const linkLabel = g.append('g')
                .selectAll('text')
                .data(links)
                .enter().append('text')
                .attr('class', 'kg-link-label')
                .text(d => KG_RELATION_LABELS[d.type] || d.type);

            // Draw nodes
            const node = g.append('g')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'kg-node')
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));

            // Node circles
            node.append('circle')
                .attr('r', 18)
                .attr('fill', d => KG_ENTITY_COLORS[d.type] || '#6b7280');

            // Node labels
            node.append('text')
                .attr('dy', 30)
                .text(d => d.name.length > 10 ? d.name.substring(0, 10) + '...' : d.name);

            // Node hover effects
            node.on('mouseenter', function(event, d) {
                // Highlight connected links
                link.attr('stroke', l => (l.source.id === d.id || l.target.id === d.id) ? '#3b82f6' : '#94a3b8')
                    .attr('stroke-width', l => (l.source.id === d.id || l.target.id === d.id) ? 3 : 2);

                // Show tooltip
                const typeLabel = KG_TYPE_LABELS[d.type] || d.type;
                tooltip.innerHTML = `
                    <div class="kg-tooltip-title">${escapeHTML(d.name)}</div>
                    <div class="kg-tooltip-type">${typeLabel}</div>
                    ${d.description ? `<div class="kg-tooltip-desc">${escapeHTML(d.description)}</div>` : ''}
                `;
                tooltip.classList.add('visible');
                tooltip.style.left = (event.offsetX + 15) + 'px';
                tooltip.style.top = (event.offsetY - 10) + 'px';
            })
            .on('mousemove', function(event) {
                tooltip.style.left = (event.offsetX + 15) + 'px';
                tooltip.style.top = (event.offsetY - 10) + 'px';
            })
            .on('mouseleave', function() {
                link.attr('stroke', '#94a3b8').attr('stroke-width', 2);
                tooltip.classList.remove('visible');
            });

            // Update positions on tick
            kgSimulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                linkLabel
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Drag functions
            function dragStarted(event, d) {
                if (!event.active) kgSimulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragEnded(event, d) {
                if (!event.active) kgSimulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function renderKGLegend(kg, container) {
            // Get unique entity types
            const types = [...new Set(kg.entities.map(e => e.entity_type))];

            let html = '';
            types.forEach(type => {
                const color = KG_ENTITY_COLORS[type] || '#6b7280';
                const label = KG_TYPE_LABELS[type] || type;
                html += `
                    <div class="kg-legend-item">
                        <div class="kg-legend-color" style="background: ${color};"></div>
                        <span>${label}</span>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function setupKGViewToggle() {
            const toggleContainer = document.getElementById('kgViewToggle');
            const graphView = document.getElementById('kgGraphView');
            const listView = document.getElementById('kgDisplayContent');

            if (!toggleContainer) return;

            toggleContainer.querySelectorAll('.kg-view-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const view = this.getAttribute('data-view');

                    // Update button states
                    toggleContainer.querySelectorAll('.kg-view-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');

                    // Toggle views
                    if (view === 'graph') {
                        graphView.style.display = 'block';
                        listView.style.display = 'none';
                        // Re-render graph if needed (handles resize)
                        if (currentKGData && graphView.clientWidth > 0) {
                            renderKGGraphView(currentKGData, graphView);
                        }
                    } else {
                        graphView.style.display = 'none';
                        listView.style.display = 'block';
                    }

                    console.log('[KG] Switched to', view, 'view');
                });
            });
        }

        // ============================================================
        // Reasoning Chain Visualization (Phase 4 - Enhanced)
        // ============================================================

        /**
         * Display reasoning chain with dependency tracking
         */
        function displayReasoningChain(argumentGraph, chainAnalysis) {
            console.log('[Reasoning Chain] Called with:', argumentGraph, chainAnalysis);

            if (!argumentGraph || argumentGraph.length === 0) {
                console.log('[Reasoning Chain] No argument graph data, skipping render');
                return;
            }

            console.log('[Reasoning Chain] Rendering', argumentGraph.length, 'nodes');

            // Build node map
            const nodeMap = {};
            argumentGraph.forEach(node => {
                nodeMap[node.node_id] = node;
            });

            // Get topological order
            let orderedNodes = argumentGraph;
            if (chainAnalysis?.topological_order && chainAnalysis.topological_order.length > 0) {
                orderedNodes = chainAnalysis.topological_order
                    .map(id => nodeMap[id])
                    .filter(node => node !== undefined);
                console.log('[Reasoning Chain] Using topological order for rendering');
            }

            // Create collapsible container
            const container = createReasoningChainContainer(orderedNodes, chainAnalysis);

            // Render logic inconsistency warning
            if (chainAnalysis?.logic_inconsistencies > 0) {
                const warning = createLogicInconsistencyWarning(chainAnalysis.logic_inconsistencies);
                container.querySelector('.reasoning-chain-content').prepend(warning);
            }

            // Render cycle warning
            if (chainAnalysis?.has_cycles) {
                const cycleAlert = createCycleWarning(chainAnalysis.cycle_details);
                container.querySelector('.reasoning-chain-content').prepend(cycleAlert);
            }

            // Render critical nodes alert
            if (chainAnalysis?.critical_nodes?.length > 0) {
                const alert = createCriticalNodesAlert(chainAnalysis.critical_nodes, nodeMap);
                container.querySelector('.reasoning-chain-content').prepend(alert);
            }

            // Render each node (with hover effects)
            orderedNodes.forEach((node, i) => {
                const nodeEl = renderArgumentNode(node, i + 1, nodeMap, chainAnalysis);
                container.querySelector('.reasoning-chain-content').appendChild(nodeEl);
            });

            // Setup hover interactions
            setupHoverInteractions(container, nodeMap);

            // Insert before report
            const listView = document.getElementById('listView');
            const reportContainer = listView.querySelector('.deep-research-report');
            if (reportContainer) {
                listView.insertBefore(container, reportContainer);
            } else {
                listView.appendChild(container);
            }
        }

        /**
         * Create container with header and toggle
         */
        function createReasoningChainContainer(nodes, chainAnalysis) {
            const container = document.createElement('div');
            container.className = 'reasoning-chain-container';
            container.style.cssText = `
                background: #f8f9fa;
                border-left: 4px solid #6366f1;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 24px;
                max-width: 900px;
                margin-left: auto;
                margin-right: auto;
            `;

            const header = document.createElement('div');
            header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; cursor: pointer;';
            header.innerHTML = `
                <div style="font-size: 18px; font-weight: 700; color: #1a1a1a;">
                    üß† Êé®Ë´ñÈèàËøΩËπ§
                    <span style="color: #666; font-size: 14px; font-weight: 400;">
                        (${nodes.length} ÂÄãÊé®Ë´ñÊ≠•È©ü${chainAnalysis?.max_depth !== undefined ? `, Ê∑±Â∫¶ ${chainAnalysis.max_depth}` : ''})
                    </span>
                </div>
                <button class="btn-toggle-chain" style="background: white; border: 1px solid #ddd; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px;">
                    Â±ïÈñã
                </button>
            `;

            const content = document.createElement('div');
            content.className = 'reasoning-chain-content';
            content.style.display = 'none';

            // Toggle functionality
            const toggleBtn = header.querySelector('.btn-toggle-chain');
            header.addEventListener('click', () => {
                const isHidden = content.style.display === 'none';
                content.style.display = isHidden ? 'block' : 'none';
                toggleBtn.textContent = isHidden ? 'Êî∂Ëµ∑' : 'Â±ïÈñã';
            });

            container.appendChild(header);
            container.appendChild(content);

            return container;
        }

        /**
         * Create logic inconsistency warning
         */
        function createLogicInconsistencyWarning(count) {
            const alert = document.createElement('div');
            alert.style.cssText = `
                background: #fef3c7;
                border-left: 4px solid #f59e0b;
                padding: 12px 16px;
                border-radius: 6px;
                margin-bottom: 16px;
            `;
            alert.innerHTML = `
                <div style="font-weight: 700; color: #92400e; margin-bottom: 4px;">‚ö†Ô∏è ÈÇèËºØ‰∏ÄËá¥ÊÄßÂïèÈ°å</div>
                <div style="color: #78350f; font-size: 13px;">
                    ÂÅµÊ∏¨Âà∞ ${count} ÂÄãÊé®Ë´ñÊ≠•È©üÁöÑ‰ø°ÂøÉÂ∫¶ÂèØËÉΩÈ´òÊñºÂÖ∂ÂâçÊèêÔºàÈÇèËºØËÜ®ËÑπÔºâ„ÄÇË´ãÊ™¢Ë¶ñÂ∏∂Êúâ ‚ö†Ô∏è Ê®ôË®òÁöÑÊé®Ë´ñÊ≠•È©ü„ÄÇ
                </div>
            `;
            return alert;
        }

        /**
         * Create cycle warning
         */
        function createCycleWarning(cycleDetails) {
            const alert = document.createElement('div');
            alert.style.cssText = `
                background: #fee2e2;
                border-left: 4px solid #dc2626;
                padding: 12px 16px;
                border-radius: 6px;
                margin-bottom: 16px;
            `;
            alert.innerHTML = `
                <div style="font-weight: 700; color: #991b1b; margin-bottom: 4px;">‚ö†Ô∏è Ê™¢Ê∏¨Âà∞Âæ™Áí∞‰æùË≥¥</div>
                <div style="color: #7f1d1d; font-size: 13px;">${cycleDetails || 'Êé®Ë´ñÈèàÂ≠òÂú®Âæ™Áí∞ÂºïÁî®ÔºåÂèØËÉΩÂΩ±ÈüøÂèØÈù†ÊÄß'}</div>
            `;
            return alert;
        }

        /**
         * Create critical nodes alert
         */
        function createCriticalNodesAlert(criticalNodes, nodeMap) {
            const alert = document.createElement('div');
            alert.style.cssText = `
                background: #fef3c7;
                border-left: 4px solid #f59e0b;
                padding: 12px 16px;
                border-radius: 6px;
                margin-bottom: 16px;
            `;

            const criticalHtml = criticalNodes.map(critical => {
                const node = nodeMap[critical.node_id];
                if (!node) return '';
                return `
                    <div style="margin-bottom: 8px; color: #78350f;">
                        <strong>„Äå${node.claim.substring(0, 50)}${node.claim.length > 50 ? '...' : ''}„Äç</strong>
                        ÂΩ±Èüø ${critical.affects_count} ÂÄãÂæåÁ∫åÊé®Ë´ñ
                        ${critical.criticality_reason ? `<br><span style="font-size: 13px;">‚îî‚îÄ ${critical.criticality_reason}</span>` : ''}
                    </div>
                `;
            }).join('');

            alert.innerHTML = `
                <div style="font-weight: 700; color: #92400e; margin-bottom: 8px;">üö® ÈóúÈçµËñÑÂº±Áí∞ÁØÄ</div>
                ${criticalHtml}
            `;

            return alert;
        }

        /**
         * Render single argument node with full details
         */
        function renderArgumentNode(node, stepNumber, nodeMap, chainAnalysis) {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'argument-node';
            nodeEl.id = `node-${node.node_id}`;
            nodeEl.setAttribute('data-node-id', node.node_id);
            nodeEl.setAttribute('data-depends', JSON.stringify(node.depends_on || []));

            // Find nodes that depend on this one (for hover highlight)
            const affectedIds = [];
            Object.values(nodeMap).forEach(n => {
                if (n.depends_on && n.depends_on.includes(node.node_id)) {
                    affectedIds.push(n.node_id);
                }
            });
            nodeEl.setAttribute('data-affects', JSON.stringify(affectedIds));

            nodeEl.style.cssText = `
                background: white;
                border: 2px solid #e5e7eb;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 12px;
                transition: all 0.2s ease;
            `;

            const emoji = {deduction: 'üî∑', induction: 'üî∂', abduction: 'üî∏'}[node.reasoning_type] || 'üí≠';
            const label = {deduction: 'ÊºîÁππ', induction: 'Ê≠∏Á¥ç', abduction: 'Ê∫ØÂõ†'}[node.reasoning_type];
            const score = node.confidence_score ?? inferScore(node.confidence);
            const scoreColor = score >= 7 ? '#16a34a' : score >= 4 ? '#f59e0b' : '#dc2626';

            // Get impact info
            let impactInfo = '';
            if (chainAnalysis?.critical_nodes) {
                const critical = chainAnalysis.critical_nodes.find(c => c.node_id === node.node_id);
                if (critical && critical.affects_count > 0) {
                    impactInfo = `<div style="color: #dc2626; font-size: 13px; margin-top: 8px;">
                        ‚ö° ÂΩ±Èüø ${critical.affects_count} ÂÄãÂæåÁ∫åÊé®Ë´ñ
                    </div>`;
                }
            }

            // Logic warnings
            let warningsHtml = '';
            if (node.logic_warnings && node.logic_warnings.length > 0) {
                warningsHtml = node.logic_warnings.map(w => `
                    <div style="color: #f59e0b; font-size: 13px; margin-top: 4px;">
                        ‚ö†Ô∏è ${w}
                    </div>
                `).join('');
            }

            // Render dependencies
            let depsHtml = '';
            if (node.depends_on && node.depends_on.length > 0) {
                const depLabels = node.depends_on.map(depId => {
                    const depIndex = Object.keys(nodeMap).indexOf(depId) + 1;
                    return `Ê≠•È©ü ${depIndex}`;
                });
                depsHtml = `<div style="color: #6366f1; font-size: 13px; margin-top: 8px;">
                    ‚Üë ‰æùË≥¥Ôºö${depLabels.join(', ')}
                </div>`;
            }

            // Evidence
            const evidenceHtml = node.evidence_ids && node.evidence_ids.length > 0
                ? `<div style="color: #666; font-size: 13px; margin-top: 4px;">
                       Ë≠âÊìö‰æÜÊ∫êÔºö${node.evidence_ids.map(id => `<span style="background: #e5e7eb; padding: 2px 6px; border-radius: 3px; margin-right: 4px;">[${id}]</span>`).join('')}
                   </div>`
                : '<div style="color: #999; font-size: 13px; margin-top: 4px;">ÁÑ°Áõ¥Êé•Ë≠âÊìöÂºïÁî®</div>';

            nodeEl.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                    <span style="background: #f3f4f6; padding: 4px 8px; border-radius: 4px; font-size: 14px;">[${stepNumber}]</span>
                    <span>${emoji} ${label}</span>
                    <span style="color: ${scoreColor}; font-size: 14px; background: ${scoreColor}22; padding: 2px 8px; border-radius: 4px;">
                        ‰ø°ÂøÉÂ∫¶ ${score.toFixed(1)}/10
                    </span>
                </div>
                <div style="color: #1a1a1a; margin-bottom: 8px; line-height: 1.6;">„Äå${node.claim}„Äç</div>
                ${evidenceHtml}
                ${depsHtml}
                ${impactInfo}
                ${warningsHtml}
            `;

            return nodeEl;
        }

        /**
         * Setup hover interactions
         */
        function setupHoverInteractions(container, nodeMap) {
            const nodes = container.querySelectorAll('.argument-node');

            nodes.forEach(nodeEl => {
                nodeEl.addEventListener('mouseenter', () => {
                    const nodeId = nodeEl.getAttribute('data-node-id');
                    const dependsOn = JSON.parse(nodeEl.getAttribute('data-depends') || '[]');
                    const affects = JSON.parse(nodeEl.getAttribute('data-affects') || '[]');

                    // Highlight current node
                    nodeEl.style.borderColor = '#6366f1';
                    nodeEl.style.boxShadow = '0 4px 12px rgba(99, 102, 241, 0.2)';

                    // Highlight dependencies (parents) - blue background
                    dependsOn.forEach(depId => {
                        const depEl = document.getElementById(`node-${depId}`);
                        if (depEl) {
                            depEl.style.backgroundColor = '#dbeafe';
                            depEl.style.borderColor = '#3b82f6';
                        }
                    });

                    // Highlight affected nodes (children) - red border
                    affects.forEach(affectedId => {
                        const affectedEl = document.getElementById(`node-${affectedId}`);
                        if (affectedEl) {
                            affectedEl.style.borderColor = '#ef4444';
                            affectedEl.style.borderWidth = '2px';
                        }
                    });
                });

                nodeEl.addEventListener('mouseleave', () => {
                    // Reset all highlights
                    nodes.forEach(n => {
                        n.style.backgroundColor = 'white';
                        n.style.borderColor = '#e5e7eb';
                        n.style.borderWidth = '2px';
                        n.style.boxShadow = 'none';
                    });
                });
            });
        }

        /**
         * Infer numerical score from confidence level
         */
        function inferScore(confidence) {
            const mapping = { 'high': 8.0, 'medium': 5.0, 'low': 2.0 };
            return mapping[confidence] || 5.0;
        }

        // KG Toggle Button Handler
        document.addEventListener('DOMContentLoaded', () => {
            const toggleButton = document.getElementById('kgToggleButton');
            const content = document.getElementById('kgDisplayContent');
            const icon = document.getElementById('kgToggleIcon');

            if (toggleButton) {
                toggleButton.addEventListener('click', () => {
                    if (content.classList.contains('collapsed')) {
                        content.classList.remove('collapsed');
                        icon.textContent = '‚ñº';
                        toggleButton.childNodes[1].textContent = ' Êî∂Ëµ∑';
                    } else {
                        content.classList.add('collapsed');
                        icon.textContent = '‚ñ∂';
                        toggleButton.childNodes[1].textContent = ' Â±ïÈñã';
                    }
                });
            }
        });

        // Free Conversation Mode function
        async function performFreeConversation(query) {
            // Add user message to chat
            addChatMessage('user', query);

            // Note: Analytics will be initialized when we receive 'begin-nlweb-response' from backend
            // with the server-generated query_id

            // Clear input
            searchInput.value = '';

            // Show loading in chatbox (not global loading)
            chatLoading.classList.add('active');
            resultsSection.classList.add('active');

            try {
                const base = window.location.origin;

                // Build conversation context including:
                // 1. Original search queries from conversationHistory
                // 2. Recent chat messages from chatHistory
                // 3. IMPORTANT: Include the original search topic explicitly
                const searchQueries = conversationHistory.slice(); // All search queries
                const recentChatHistory = chatHistory.slice(-4); // Last 4 chat messages
                const chatQueries = recentChatHistory.filter(msg => msg.role === 'user').map(msg => msg.content);

                // Combine: original search context + recent chat
                const allPrevQueries = [...searchQueries, ...chatQueries];

                // Use ALL accumulated articles as reference for UI display
                let referenceContext = '';
                if (accumulatedArticles.length > 0) {
                    referenceContext = `ÂèÉËÄÉË≥áÊñôÔºöÂü∫Êñº ${accumulatedArticles.length} ÂâáÊñ∞ËÅûÔºà‰æÜËá™ ${conversationHistory.length} Ê¨°ÊêúÂ∞ãÔºâ`;
                }

                console.log('=== Free Conversation Debug ===');
                console.log('Current query:', query);
                console.log('Search queries (from conversationHistory):', searchQueries);
                console.log('Chat queries (from chatHistory):', chatQueries);
                console.log('All prev queries being sent:', allPrevQueries);
                console.log('Total accumulated articles:', accumulatedArticles.length);

                // Call with prev parameter (like normal conversation)
                const chatUrl = new URL('/ask', base);
                chatUrl.searchParams.append('query', query); // Send original query, backend handles context
                chatUrl.searchParams.append('site', 'all');
                chatUrl.searchParams.append('generate_mode', 'generate');
                chatUrl.searchParams.append('streaming', 'true');
                chatUrl.searchParams.append('free_conversation', 'true'); // Backend flag for free chat mode

                // Send full context: original search + chat history
                if (allPrevQueries.length > 0) {
                    chatUrl.searchParams.append('prev', JSON.stringify(allPrevQueries));
                }

                console.log('Chat URL:', chatUrl.toString());

                let chatData = await handleStreamingRequest(chatUrl.toString(), query);

                // Add assistant response to chat
                if (chatData.answer) {
                    addChatMessage('assistant', chatData.answer, referenceContext);
                } else {
                    addChatMessage('assistant', 'Êä±Ê≠âÔºåÊàëÁÑ°Ê≥ïÂõûÁ≠îÈÄôÂÄãÂïèÈ°å„ÄÇ');
                }

                chatLoading.classList.remove('active');

                // Scroll chat to bottom
                chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            } catch (error) {
                console.error('Chat failed:', error);
                chatLoading.classList.remove('active');
                addChatMessage('assistant', 'Êä±Ê≠âÔºåÁôºÁîüÈåØË™§„ÄÇË´ãÁ®çÂæåÂÜçË©¶„ÄÇ');
            }
        }

        // Add message to chat UI
        function addChatMessage(role, content, referenceInfo = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;

            const headerText = role === 'user' ? '‰Ω†' : 'AI Âä©ÁêÜ';

            // For assistant messages, convert markdown links and render HTML
            let formattedContent = content;
            if (role === 'assistant') {
                formattedContent = convertMarkdownToHtml(content);
            } else {
                formattedContent = escapeHTML(content);
            }

            let messageHTML = `
                <div class="chat-message-header">${headerText}</div>
                <div class="chat-message-bubble">${formattedContent}</div>
            `;

            if (referenceInfo && role === 'assistant') {
                messageHTML += `<div class="chat-reference-info">üìö ${referenceInfo}</div>`;
            }

            messageDiv.innerHTML = messageHTML;
            chatMessagesEl.appendChild(messageDiv);

            // Store in chat history
            chatHistory.push({ role, content, timestamp: Date.now() });

            // Scroll to bottom
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }

        // Add clarification message to chat (conversational)
        function addClarificationMessage(clarificationData, originalQuery, eventSource, savedQuery) {
            console.log('[Clarification] Adding multi-dimensional clarification:', clarificationData);

            // Hide loading state
            const loadingState = document.getElementById('loadingState');
            if (loadingState) {
                loadingState.classList.remove('active');
            }

            // Get chat elements (should already be active from performDeepResearch)
            const chatMessagesEl = document.getElementById('chatMessages');
            if (!chatMessagesEl) {
                console.error('[Clarification] Chat messages element not found');
                return;
            }

            // Icon mapping for question types
            const iconMap = {
                'time': 'üïí',
                'scope': 'üéØ',
                'entity': 'üåê'
            };

            // Create clarification card
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message assistant clarification';

            // Build clarification card HTML
            let contentHTML = '<div class="chat-message-header">AI Âä©ÁêÜ</div>';
            contentHTML += '<div class="chat-message-bubble">';
            contentHTML += '<div class="clarification-card">';

            // Header with instruction
            contentHTML += `
                <div class="clarification-header">
                    ${clarificationData.instruction || 'ÁÇ∫‰∫ÜÁ≤æÊ∫ñÊêúÂ∞ã'}„Äå${escapeHTML(originalQuery)}„ÄçÔºåË´ãÈÅ∏Êìá‰ª•‰∏ãÊ¢ù‰ª∂
                </div>
            `;

            // Render each question block
            clarificationData.questions.forEach(question => {
                const icon = iconMap[question.clarification_type] || '‚ùì';
                const requiredMark = question.required ? '<span class="required">*</span>' : '';

                contentHTML += `
                    <div class="question-block" data-question-id="${question.question_id}">
                        <div class="question-label">
                            <span class="question-icon">${icon}</span>
                            <span class="question-text">${question.question}${requiredMark}</span>
                        </div>
                        <div class="options-group">
                `;

                // Add option chips
                question.options.forEach(opt => {
                    const queryModifier = opt.query_modifier || '';
                    const isComprehensive = opt.is_comprehensive || false;

                    contentHTML += `
                        <button class="option-chip"
                                data-option-id="${opt.id}"
                                data-label="${escapeHTML(opt.label)}"
                                data-query-modifier="${escapeHTML(queryModifier)}"
                                data-is-comprehensive="${isComprehensive}">
                            ${escapeHTML(opt.label)}
                        </button>
                    `;
                });

                contentHTML += '</div></div>';
            });

            // Submit button
            contentHTML += `
                <button class="submit-clarification" disabled>
                    ${clarificationData.submit_label || 'ÈñãÂßãÊêúÂ∞ã'}
                </button>
            `;

            contentHTML += '</div></div>'; // Close card and bubble

            messageDiv.innerHTML = contentHTML;
            chatMessagesEl.appendChild(messageDiv);
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;

            console.log('[Clarification] Multi-question card rendered');

            // Attach event listeners
            attachClarificationListeners(messageDiv, clarificationData, originalQuery, eventSource);
        }

        // Attach event listeners for multi-question clarification
        function attachClarificationListeners(container, clarificationData, originalQuery, eventSource) {
            const questions = clarificationData.questions;
            const selectedAnswers = {}; // {question_id: {label, query_modifier, is_comprehensive}}

            // Option click handler
            container.querySelectorAll('.option-chip').forEach(chip => {
                chip.addEventListener('click', function() {
                    const questionBlock = this.closest('.question-block');
                    const questionId = questionBlock.dataset.questionId;

                    // Toggle selection (single select per question)
                    questionBlock.querySelectorAll('.option-chip').forEach(c => c.classList.remove('selected'));
                    this.classList.add('selected');

                    // Store selection
                    selectedAnswers[questionId] = {
                        label: this.dataset.label,
                        query_modifier: this.dataset.queryModifier,
                        is_comprehensive: this.dataset.isComprehensive === 'true'
                    };

                    console.log('[Clarification] Selected:', questionId, selectedAnswers[questionId]);

                    // Enable submit if all required questions answered
                    const submitBtn = container.querySelector('.submit-clarification');
                    const allAnswered = questions.every(q => selectedAnswers[q.question_id]);
                    submitBtn.disabled = !allAnswered;

                    if (allAnswered) {
                        console.log('[Clarification] All questions answered, submit enabled');
                    }
                });
            });

            // Submit button handler
            container.querySelector('.submit-clarification').addEventListener('click', () => {
                submitClarification(selectedAnswers, originalQuery, eventSource, questions);
            });
        }

        // Submit clarification response with natural language query building
        function submitClarification(selectedAnswers, originalQuery, eventSource, questions) {
            console.log('[Clarification] Submitting answers:', selectedAnswers);
            console.log('[Clarification] Original query:', originalQuery);

            // Close event source
            if (eventSource) {
                eventSource.close();
            }

            // Build clarified query using natural language (ÊñπÊ°à B)
            let clarifiedQuery = originalQuery;
            let allComprehensive = true;

            // Separate answers by clarification type
            let timeModifier = '';
            let scopeModifier = '';
            let entityModifier = '';

            questions.forEach(q => {
                const answer = selectedAnswers[q.question_id];
                if (!answer) return;

                // Check if user chose comprehensive option
                if (!answer.is_comprehensive) {
                    allComprehensive = false;
                }

                // Collect modifiers by type
                if (answer.query_modifier) {
                    if (q.clarification_type === 'time') {
                        timeModifier = answer.query_modifier;
                    } else if (q.clarification_type === 'scope') {
                        scopeModifier = answer.query_modifier;
                    } else if (q.clarification_type === 'entity') {
                        entityModifier = answer.query_modifier;
                    }
                }
            });

            // Build natural language query
            // Strategy: time modifier goes before, scope modifier goes after
            if (timeModifier && scopeModifier) {
                // Example: "Ëî°Ëã±ÊñáÂç∏‰ªªÂæåÁöÑÂÖ©Â≤∏ÊîøÁ≠ñÔºåËÅöÁÑ¶Â§ñ‰∫§Èóú‰øÇ"
                clarifiedQuery = `${originalQuery}(${timeModifier}Ôºå${scopeModifier})`;
            } else if (timeModifier) {
                // Example: "Ëî°Ëã±ÊñáÂÖ©Â≤∏ÊîøÁ≠ñ(‰ªªÊúüÂÖß)"
                clarifiedQuery = `${originalQuery}(${timeModifier})`;
            } else if (scopeModifier) {
                // Example: "momoÁßëÊäÄ(ÁáüÈÅãË≤°Â†±Èù¢Âêë)"
                clarifiedQuery = `${originalQuery}(${scopeModifier})`;
            } else if (entityModifier) {
                // Example: "Êô∂ÁâáÊ≥ïÊ°à(ÁæéÂúã)"
                clarifiedQuery = `${entityModifier}${originalQuery}`;
            }

            console.log('[Clarification] Clarified query:', clarifiedQuery);
            console.log('[Clarification] All comprehensive:', allComprehensive);

            // Add user message showing selection
            const chatMessagesEl = document.getElementById('chatMessages');
            const userMessageDiv = document.createElement('div');
            userMessageDiv.className = 'chat-message user';

            const selectionText = Object.values(selectedAnswers).map(a => a.label).join(' + ');
            userMessageDiv.innerHTML = `
                <div class="chat-message-header">‰Ω†</div>
                <div class="chat-message-bubble">${escapeHTML(selectionText)}</div>
            `;
            chatMessagesEl.appendChild(userMessageDiv);
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;

            // Re-submit with skip_clarification flag
            console.log('[Clarification] Re-submitting with skip_clarification=true');
            performDeepResearch(clarifiedQuery, true, allComprehensive);
        }

        // View tabs
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const view = tab.dataset.view;

                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Switch views
                if (view === 'list') {
                    listView.style.display = 'flex';
                    timelineView.classList.remove('active');
                    summaryToggle.classList.add('active');
                } else {
                    listView.style.display = 'none';
                    timelineView.classList.add('active');
                    summaryToggle.classList.add('active'); // Keep toggle visible in timeline view too
                }
            });
        });

        // Summary toggle
        btnToggleSummary.addEventListener('click', () => {
            if (!summaryExpanded) {
                // Expand summary - just show the descriptions that are already loaded
                showSummaries();
                summaryExpanded = true;
                btnToggleSummary.textContent = 'üìù Êî∂Ëµ∑ÊëòË¶Å';
            } else {
                // Collapse summary
                hideSummaries();
                summaryExpanded = false;
                btnToggleSummary.textContent = 'üìù Â±ïÈñãÊëòË¶Å';
            }
        });

        function showSummaries() {
            // Show excerpts in both list and timeline views
            const listExcerpts = listView.querySelectorAll('.news-excerpt');
            listExcerpts.forEach(excerpt => excerpt.classList.add('visible'));

            const timelineExcerpts = timelineView.querySelectorAll('.news-excerpt');
            timelineExcerpts.forEach(excerpt => excerpt.classList.add('visible'));
        }

        function hideSummaries() {
            // Hide excerpts in both list and timeline views
            const listExcerpts = listView.querySelectorAll('.news-excerpt');
            listExcerpts.forEach(excerpt => excerpt.classList.remove('visible'));

            const timelineExcerpts = timelineView.querySelectorAll('.news-excerpt');
            timelineExcerpts.forEach(excerpt => excerpt.classList.remove('visible'));
        }

        // Share modal
        btnShare.addEventListener('click', () => {
            modalOverlay.classList.add('active');
        });

        btnCloseModal.addEventListener('click', () => {
            modalOverlay.classList.remove('active');
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.classList.remove('active');
            }
        });

        // My Searches modal handlers
        btnMySearches.addEventListener('click', () => {
            renderSavedSessions();
            mySearchesModal.classList.add('active');
        });

        btnCloseMySearches.addEventListener('click', () => {
            mySearchesModal.classList.remove('active');
        });

        mySearchesModal.addEventListener('click', (e) => {
            if (e.target === mySearchesModal) {
                mySearchesModal.classList.remove('active');
            }
        });

        // Track delete confirmation state
        let deleteConfirmTimeout = null;

        // Function to handle delete session with two-click confirmation
        function handleDeleteSession(sessionId, deleteBtn) {
            if (deleteBtn.classList.contains('confirming')) {
                // Second click - actually delete
                deleteSavedSession(sessionId);
            } else {
                // First click - show confirmation
                deleteBtn.classList.add('confirming');
                deleteBtn.textContent = 'Á¢∫ÂÆöÂà™Èô§';

                // Clear any existing timeout
                if (deleteConfirmTimeout) {
                    clearTimeout(deleteConfirmTimeout);
                }

                // Reset after 3 seconds if not confirmed
                deleteConfirmTimeout = setTimeout(() => {
                    deleteBtn.classList.remove('confirming');
                    deleteBtn.textContent = '‚úï';
                }, 3000);
            }
        }

        // Function to delete a saved session
        function deleteSavedSession(sessionId) {
            console.log('Deleting session:', sessionId);

            // Remove from savedSessions array
            savedSessions = savedSessions.filter(s => s.id !== sessionId);

            // Update localStorage
            localStorage.setItem('taiwanNewsSavedSessions', JSON.stringify(savedSessions));

            // If the deleted session is currently loaded, reset the interface
            if (currentLoadedSessionId === sessionId) {
                currentLoadedSessionId = null;
                conversationHistory = [];
                sessionHistory = [];
                chatHistory = [];
                accumulatedArticles = [];

                // Clear UI
                resultsSection.style.display = 'none';
                initialState.style.display = 'flex';
                searchInput.value = '';
                renderConversationHistory();

                // Switch back to search mode if in chat mode
                if (currentMode === 'chat') {
                    switchMode('search');
                }
            }

            // Re-render the sessions list
            renderSavedSessions();
        }

        // Function to render saved sessions
        function renderSavedSessions() {
            savedSessionsList.innerHTML = '';

            if (savedSessions.length === 0) {
                savedSessionsList.innerHTML = '<div class="empty-sessions">Â∞öÁÑ°ÂÑ≤Â≠òÁöÑÊêúÂ∞ãË®òÈåÑ</div>';
                return;
            }

            // Render sessions in reverse order (newest first)
            savedSessions.slice().reverse().forEach((session) => {
                const sessionItem = document.createElement('div');
                sessionItem.className = 'saved-session-item';

                const date = new Date(session.createdAt);
                const dateStr = date.toLocaleDateString('zh-TW', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                // Count chat messages if they exist
                const chatCount = session.chatHistory ? session.chatHistory.length : 0;
                const chatInfo = chatCount > 0 ? ` ‚Ä¢ ${chatCount} ÂâáÂ∞çË©±` : '';

                sessionItem.innerHTML = `
                    <button class="delete-btn" data-session-id="${session.id}">‚úï</button>
                    <div class="saved-session-title">${escapeHTML(session.title)}</div>
                    <div class="saved-session-meta">
                        <span class="saved-session-queries">${session.conversationHistory.length} ÂÄãÊü•Ë©¢${chatInfo}</span>
                        <span>${dateStr}</span>
                    </div>
                `;

                // Add delete button handler
                const deleteBtn = sessionItem.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent session load
                    handleDeleteSession(session.id, deleteBtn);
                });

                sessionItem.addEventListener('click', () => {
                    loadSavedSession(session);
                    mySearchesModal.classList.remove('active');
                });

                savedSessionsList.appendChild(sessionItem);
            });
        }

        // Function to load a saved session
        function loadSavedSession(session) {
            console.log('Loading saved session:', session);

            // Track this session's ID to prevent duplicate saves
            currentLoadedSessionId = session.id;

            // Restore conversation history and session data
            conversationHistory = [...session.conversationHistory];
            sessionHistory = [...session.sessionHistory];

            // Restore chat history and accumulated articles (if they exist)
            chatHistory = session.chatHistory ? [...session.chatHistory] : [];
            accumulatedArticles = session.accumulatedArticles ? [...session.accumulatedArticles] : [];

            // Render the last query's results
            if (sessionHistory.length > 0) {
                const lastSession = sessionHistory[sessionHistory.length - 1];
                populateResultsFromAPI(lastSession.data, lastSession.query);
            }

            // Update conversation history display
            renderConversationHistory();

            // Restore chat UI if there were chat messages
            if (chatHistory.length > 0) {
                console.log(`Restoring ${chatHistory.length} chat messages`);
                chatMessagesEl.innerHTML = ''; // Clear existing messages

                // Re-render all chat messages
                chatHistory.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `chat-message ${msg.role}`;

                    const headerText = msg.role === 'user' ? '‰Ω†' : 'AI Âä©ÁêÜ';

                    // Format content based on role
                    let formattedContent = msg.content;
                    if (msg.role === 'assistant') {
                        formattedContent = convertMarkdownToHtml(msg.content);
                    } else {
                        formattedContent = escapeHTML(msg.content);
                    }

                    messageDiv.innerHTML = `
                        <div class="chat-message-header">${headerText}</div>
                        <div class="chat-message-bubble">${formattedContent}</div>
                    `;

                    chatMessagesEl.appendChild(messageDiv);
                });

                // Show chat container if we restored messages
                chatContainer.classList.add('active');

                // Optionally switch to chat mode
                currentMode = 'chat';
                modeButtons.forEach(btn => btn.classList.remove('active')); modeButtons[2].classList.add('active');
                btnSearch.textContent = 'ÁôºÈÄÅ';
                searchInput.placeholder = 'ÁπºÁ∫åÂ∞çË©±...';

                // Move search container into chat area
                chatInputContainer.appendChild(searchContainer);
                chatInputContainer.style.display = 'block';

                // Scroll to bottom of chat
                chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            }

            // Show results section and hide initial state
            initialState.style.display = 'none';
            resultsSection.classList.add('active');

            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // ===== Export/Share Functions =====

        // Helper: Clean HTML content for different export formats
        function cleanHTMLContent(content, format = 'plain') {
            if (!content) return '';

            if (format === 'plain') {
                // Strip all HTML and markdown links
                return content
                    .replace(/<br\s*\/?>/gi, '\n')
                    .replace(/<[^>]+>/g, '')
                    .replace(/\[‰æÜÊ∫ê\]\([^\)]+\)/g, '')
                    .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1'); // Keep link text only
            } else if (format === 'markdown') {
                // Keep markdown, convert <br> to newlines
                return content.replace(/<br\s*\/?>/gi, '\n\n');
            }

            return content;
        }

        // Helper: Get top 10 articles from the most recent search
        function getTop10Articles() {
            if (sessionHistory.length === 0) return [];
            const lastSession = sessionHistory[sessionHistory.length - 1];
            if (!lastSession.data || !lastSession.data.content) return [];
            return lastSession.data.content.slice(0, 10);
        }

        // Format content for plain text export
        function formatPlainText() {
            let content = '';
            const date = new Date().toLocaleDateString('zh-TW', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            content += `Âè∞ÁÅ£Êñ∞ËÅûÊêúÂ∞ãÁµêÊûú\n`;
            content += `Êó•ÊúüÔºö${date}\n`;
            content += `${'='.repeat(50)}\n\n`;

            // Search queries
            if (conversationHistory.length > 0) {
                content += `„ÄêÊêúÂ∞ãÊü•Ë©¢„Äë\n`;
                conversationHistory.forEach((query, idx) => {
                    content += `${idx + 1}. ${query}\n`;
                });
                content += `\n`;
            }

            // AI answers from search results
            if (sessionHistory.length > 0) {
                content += `„ÄêAI ÂàÜÊûêÊëòË¶Å„Äë\n`;
                sessionHistory.forEach((session, idx) => {
                    if (session.data && session.data.answer) {
                        const plainAnswer = cleanHTMLContent(session.data.answer, 'plain');
                        content += `${plainAnswer}\n\n`;
                    }
                });
            }

            // Free conversation messages
            if (chatHistory.length > 0) {
                content += `„ÄêËá™Áî±Â∞çË©±Á¥ÄÈåÑ„Äë\n`;
                chatHistory.forEach(msg => {
                    const icon = msg.role === 'user' ? 'üë§ ‰Ω†' : 'ü§ñ AI';
                    const plainContent = cleanHTMLContent(msg.content, 'plain');
                    content += `${icon}Ôºö${plainContent}\n\n`;
                });
            }

            // Top 10 articles
            const top10 = getTop10Articles();
            if (top10.length > 0) {
                content += `„ÄêÁõ∏ÈóúÊñ∞ËÅûÊñáÁ´†Ôºà${top10.length} ÁØáÔºâ„Äë\n`;
                top10.forEach((article, idx) => {
                    const title = article.name || article.schema_object?.headline || 'ÁÑ°Ê®ôÈ°å';
                    const source = article.schema_object?.publisher?.name || article.site || 'Êú™Áü•‰æÜÊ∫ê';
                    const date = article.schema_object?.datePublished?.split('T')[0] || 'Êú™Áü•Êó•Êúü';
                    const desc = article.description || article.ranking?.description || '';

                    content += `${idx + 1}. ${title}\n`;
                    content += `   ‰æÜÊ∫êÔºö${source} | Êó•ÊúüÔºö${date}\n`;
                    if (desc) {
                        content += `   ${desc}\n`;
                    }
                    content += `\n`;
                });
            }

            return content;
        }

        // Format content for AI chatbot (ChatGPT/Claude/Gemini)
        function formatForAIChatbot() {
            let content = '';

            // Opening context
            if (conversationHistory.length > 0) {
                content += `ÊàëÂâõÊêúÂ∞ã‰∫ÜÈóúÊñº„Äå${conversationHistory[0]}„ÄçÁöÑÂè∞ÁÅ£Êñ∞ËÅûÔºå‰ª•‰∏ãÊòØÊêúÂ∞ãÁµêÊûúÔºö\n\n`;
            }

            // Search queries
            if (conversationHistory.length > 1) {
                content += `„ÄêÊêúÂ∞ãÊü•Ë©¢„Äë\n`;
                conversationHistory.forEach((query, idx) => {
                    content += `${idx + 1}. ${query}\n`;
                });
                content += `\n`;
            }

            // AI analysis
            if (sessionHistory.length > 0) {
                content += `„ÄêAI ÂàÜÊûêÊëòË¶Å„Äë\n`;
                sessionHistory.forEach((session, idx) => {
                    if (session.data && session.data.answer) {
                        const cleanAnswer = cleanHTMLContent(session.data.answer, 'markdown');
                        content += `${cleanAnswer}\n\n`;
                    }
                });
            }

            // Free conversation
            if (chatHistory.length > 0) {
                content += `„ÄêËá™Áî±Â∞çË©±Á¥ÄÈåÑ„Äë\n`;
                chatHistory.forEach(msg => {
                    const icon = msg.role === 'user' ? 'üë§ ‰Ω†' : 'ü§ñ AI';
                    const cleanContent = cleanHTMLContent(msg.content, 'markdown');
                    content += `${icon}Ôºö${cleanContent}\n\n`;
                });
            }

            // Articles with URLs
            const top10 = getTop10Articles();
            if (top10.length > 0) {
                content += `„ÄêÁõ∏ÈóúÊñ∞ËÅû‰æÜÊ∫êÔºà${top10.length} ÁØáÔºâ„Äë\n`;
                top10.forEach((article, idx) => {
                    const title = article.name || article.schema_object?.headline || 'ÁÑ°Ê®ôÈ°å';
                    const url = article.url || article.schema_object?.url || '';
                    const source = article.schema_object?.publisher?.name || article.site || '';
                    const date = article.schema_object?.datePublished?.split('T')[0] || '';
                    const desc = article.description || article.ranking?.description || '';

                    content += `${idx + 1}. ${title}\n`;
                    if (url) content += `   Á∂≤ÂùÄÔºö${url}\n`;
                    if (source || date) content += `   ‰æÜÊ∫êÔºö${source} | Êó•ÊúüÔºö${date}\n`;
                    if (desc) content += `   ÊëòË¶ÅÔºö${desc}\n`;
                    content += `\n`;
                });
            }

            content += `---\nË´ãÂü∫Êñº‰ª•‰∏äË≥áË®äÂπ´ÊàëÈÄ≤Ë°åÂàÜÊûê„ÄÇ`;

            return content;
        }

        // Format content for NotebookLM (rich markdown with full details)
        function formatForNotebookLM() {
            let content = '';
            const date = new Date().toLocaleDateString('zh-TW', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            // Title
            if (conversationHistory.length > 0) {
                content += `# Âè∞ÁÅ£Êñ∞ËÅûÊêúÂ∞ãÔºö${conversationHistory[0]}\n\n`;
            } else {
                content += `# Âè∞ÁÅ£Êñ∞ËÅûÊêúÂ∞ãÁµêÊûú\n\n`;
            }

            content += `**ÊêúÂ∞ãÊó•Êúü**: ${date}\n\n`;
            content += `---\n\n`;

            // Search queries
            if (conversationHistory.length > 0) {
                content += `## ÊêúÂ∞ãÊü•Ë©¢\n\n`;
                conversationHistory.forEach((query, idx) => {
                    content += `${idx + 1}. ${query}\n`;
                });
                content += `\n`;
            }

            // AI analysis
            if (sessionHistory.length > 0) {
                content += `## AI ÂàÜÊûêÊëòË¶Å\n\n`;
                sessionHistory.forEach((session, idx) => {
                    if (session.data && session.data.answer) {
                        const cleanAnswer = cleanHTMLContent(session.data.answer, 'markdown');
                        content += `${cleanAnswer}\n\n`;
                    }
                });
            }

            // Free conversation
            if (chatHistory.length > 0) {
                content += `## Ëá™Áî±Â∞çË©±Á¥ÄÈåÑ\n\n`;
                chatHistory.forEach(msg => {
                    const role = msg.role === 'user' ? '**‰Ω†**' : '**AI Âä©ÁêÜ**';
                    const cleanContent = cleanHTMLContent(msg.content, 'markdown');
                    content += `${role}: ${cleanContent}\n\n`;
                });
            }

            // Detailed articles
            const top10 = getTop10Articles();
            if (top10.length > 0) {
                content += `## Áõ∏ÈóúÊñ∞ËÅû‰æÜÊ∫êÔºà${top10.length} ÁØáÔºâ\n\n`;
                top10.forEach((article, idx) => {
                    const title = article.name || article.schema_object?.headline || 'ÁÑ°Ê®ôÈ°å';
                    const url = article.url || article.schema_object?.url || '';
                    const source = article.schema_object?.publisher?.name || article.site || '';
                    const date = article.schema_object?.datePublished?.split('T')[0] || '';
                    const desc = article.description || article.ranking?.description || '';

                    content += `### ${idx + 1}. ${title}\n\n`;
                    if (source) content += `- **‰æÜÊ∫ê**: ${source}\n`;
                    if (date) content += `- **Êó•Êúü**: ${date}\n`;
                    if (url) content += `- **Á∂≤ÂùÄ**: ${url}\n`;
                    if (desc) content += `\n${desc}\n`;
                    content += `\n---\n\n`;
                });
            }

            return content;
        }

        // Copy to clipboard and optionally open URL
        async function copyAndOpen(text, url = null, buttonElement) {
            const originalText = buttonElement.textContent;

            try {
                await navigator.clipboard.writeText(text);

                // Visual feedback
                buttonElement.textContent = '‚úì Â∑≤Ë§áË£ΩÔºÅ';
                buttonElement.style.borderColor = '#059669';
                buttonElement.style.color = '#059669';

                // Open URL if provided
                if (url) {
                    window.open(url, '_blank');
                }

                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.style.borderColor = '';
                    buttonElement.style.color = '';
                }, 2000);

            } catch (err) {
                console.error('Ë§áË£ΩÂ§±Êïó:', err);
                buttonElement.textContent = '‚úó Ë§áË£ΩÂ§±Êïó';
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                }, 2000);
            }
        }

        // Button handlers
        const btnCopyPlainText = document.getElementById('btnCopyPlainText');
        const btnCopyChatGPT = document.getElementById('btnCopyChatGPT');
        const btnCopyClaude = document.getElementById('btnCopyClaude');
        const btnCopyGemini = document.getElementById('btnCopyGemini');
        const btnCopyNotebookLM = document.getElementById('btnCopyNotebookLM');

        btnCopyPlainText.addEventListener('click', () => {
            const content = formatPlainText();
            copyAndOpen(content, null, btnCopyPlainText);
        });

        btnCopyChatGPT.addEventListener('click', () => {
            const content = formatForAIChatbot();
            copyAndOpen(content, 'https://chat.openai.com/', btnCopyChatGPT);
        });

        btnCopyClaude.addEventListener('click', () => {
            const content = formatForAIChatbot();
            copyAndOpen(content, 'https://claude.ai/', btnCopyClaude);
        });

        btnCopyGemini.addEventListener('click', () => {
            const content = formatForAIChatbot();
            copyAndOpen(content, 'https://gemini.google.com/', btnCopyGemini);
        });

        btnCopyNotebookLM.addEventListener('click', () => {
            const content = formatForNotebookLM();
            copyAndOpen(content, 'https://notebooklm.google.com/', btnCopyNotebookLM);
        });

        // Feedback buttons
        const feedbackButtons = document.querySelectorAll('.btn-feedback');
        feedbackButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const originalText = btn.textContent;
                btn.textContent = btn.textContent.includes('üëç') ? '‚úì Â∑≤ÂõûÈ•ã' : '‚úì Â∑≤ÂõûÂ†±';
                btn.style.color = '#059669';

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.color = '';
                }, 2000);
            });
        });

        // Phase 4: Clarification Modal Functions
        function showClarificationModal(clarificationData, originalQuery, eventSource) {
            console.log('[Clarification] Showing modal:', clarificationData);

            const modal = document.getElementById('clarificationModal');
            const hint = document.getElementById('clarificationHint');
            const optionsContainer = document.getElementById('clarificationOptions');
            const fallback = document.getElementById('clarificationFallback');

            // Set hint text
            hint.textContent = clarificationData.context_hint || 'Ë´ãÈÅ∏Êìá‰∏ÄÂÄãÈÅ∏È†ÖÔºö';

            // Clear previous options
            optionsContainer.innerHTML = '';

            // Create option buttons
            clarificationData.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'clarification-option';
                button.textContent = option.label;
                button.style.cssText = 'padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; background: white; color: #111827; cursor: pointer; font-size: 14px; text-align: left; transition: all 0.2s;';

                button.onmouseover = () => {
                    button.style.borderColor = '#3b82f6';
                    button.style.background = '#eff6ff';
                };
                button.onmouseout = () => {
                    button.style.borderColor = '#e2e8f0';
                    button.style.background = 'white';
                };

                button.onclick = () => {
                    handleClarificationChoice(option, originalQuery, eventSource);
                };

                optionsContainer.appendChild(button);
            });

            // Show fallback suggestion
            if (clarificationData.fallback_suggestion) {
                fallback.textContent = clarificationData.fallback_suggestion;
                fallback.style.display = 'block';
            } else {
                fallback.style.display = 'none';
            }

            // Show modal
            modal.classList.add('active');

            // Hide loading state
            loadingState.classList.remove('active');
        }

        function closeClarificationModal() {
            const modal = document.getElementById('clarificationModal');
            modal.classList.remove('active');
        }

        async function handleClarificationChoice(option, originalQuery, eventSource) {
            console.log('[Clarification] User selected:', option);

            // Close modal
            closeClarificationModal();

            // Close the original event source
            if (eventSource) {
                eventSource.close();
            }

            // Show loading again
            loadingState.classList.add('active');

            // Extract time_range if available
            const timeRange = option.time_range;

            // Reconstruct query with clarification
            // Option A: Modify query string to include selected option
            let clarifiedQuery = originalQuery;
            if (timeRange && timeRange.start) {
                // Add time info to query
                clarifiedQuery = `${originalQuery} (${option.label})`;
            }

            // Re-submit the search with clarified parameters
            // For Deep Research mode
            if (currentMode === 'deep_research') {
                console.log('[Clarification] Re-submitting Deep Research with:', clarifiedQuery);

                // Store the time_range in query_params for backend
                // This will be picked up by the handler
                const base = window.location.origin;
                const deepResearchUrl = new URL('/api/deep_research', base);  // Corrected endpoint
                deepResearchUrl.searchParams.append('query', clarifiedQuery);
                deepResearchUrl.searchParams.append('site', 'all');
                deepResearchUrl.searchParams.append('research_mode', currentResearchMode);
                deepResearchUrl.searchParams.append('max_iterations', '3');
                deepResearchUrl.searchParams.append('skip_clarification', 'true');  // Skip clarification check

                // Add time_range as JSON if available (only if both start and end exist)
                if (timeRange && timeRange.start && timeRange.end) {
                    deepResearchUrl.searchParams.append('time_range_start', timeRange.start);
                    deepResearchUrl.searchParams.append('time_range_end', timeRange.end);
                }

                if (currentConversationId) {
                    deepResearchUrl.searchParams.append('conversation_id', currentConversationId);
                }

                // Restart Deep Research with clarified query
                const newEventSource = new EventSource(deepResearchUrl.toString());

                newEventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('Deep Research SSE (clarified):', data);

                        // Handle messages same as normal Deep Research
                        if (data.message_type === 'intermediate_result') {
                            updateReasoningProgress(data);
                        } else if (data.message_type === 'final_result') {
                            newEventSource.close();
                            loadingState.classList.remove('active');
                            displayDeepResearchResults(data.final_report || '', data, clarifiedQuery);
                        }
                    } catch (e) {
                        console.error('Error parsing SSE message:', e);
                    }
                };

                newEventSource.onerror = (error) => {
                    console.error('SSE error:', error);
                    newEventSource.close();
                    loadingState.classList.remove('active');
                };
            }
        }

    </script>

    <!-- Phase 4: Clarification Modal -->
    <div id="clarificationModal" class="modal-overlay">
        <div class="modal" style="max-width: 600px;">
            <h2 style="margin: 0 0 16px 0; font-size: 20px; color: #111827;">ÈúÄË¶ÅÊæÑÊ∏ÖÊü•Ë©¢ÂÖßÂÆπ</h2>
            <p id="clarificationHint" style="margin: 0 0 24px 0; color: #64748b; font-size: 14px;"></p>

            <div id="clarificationOptions" style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 24px;">
                <!-- Options will be dynamically inserted here -->
            </div>

            <div id="clarificationFallback" style="margin-top: 16px; padding: 12px; background: #f8fafc; border-radius: 8px; font-size: 13px; color: #64748b; display: none;">
                <!-- Fallback suggestion will be inserted here -->
            </div>

            <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px;">
                <button onclick="closeClarificationModal()" style="padding: 8px 16px; border: 1px solid #e2e8f0; border-radius: 6px; background: white; color: #64748b; cursor: pointer; font-size: 14px;">
                    ÂèñÊ∂à
                </button>
            </div>
        </div>
    </div>

</body>
</html>